{"version":3,"sources":["webpack://mina-template/../node_modules/@we-mobius/mobius-mina/src/es/theme.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/base.atom.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/data.atom.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/mutation.atom.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/base.mediators.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/replay.mediators.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/meta.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/functional/helpers.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/internal/base.js"],"names":[],"mappings":"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A,yBAAyB,gDAAU;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA,aAAa,EAAE,sBAAsB,EAAE;AACvC;AACA,8DAA8D,kBAAkB;AAChF,cAAc,GAAG,EAAE;AACnB;AACA,wCAAwC;AACxC;AACA,mEAAmE,QAAQ;AAC3E;AACA,SAAS,wDAAU;AACnB,4FAA4F,eAAe;AAC3G;AACA,SAAS,sDAAQ;AACjB,0FAA0F,eAAe;AACzG;;AAEA,WAAW,oBAAoB;;AAE/B;AACA,WAAW,mDAAS;AACpB,kBAAkB,gDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnO4C;AACO;;AAE5C,0BAA0B,sDAAQ;;AAElC;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oDAAI;AACf;;AAEA;AACA;AACA;AACA,WAAW,uDAAO;AAClB;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpIsD;AACnB;AACe;AACN;;AAErC,gCAAgC,sDAAQ;;AAExC,6BAA6B,4DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,gDAAM;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,sDAAQ;AAChB;AACA,KAAK,UAAU,sDAAQ;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL,8HAA8H,eAAe;AAC7I;;AAEA,WAAW,iCAAiC;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,sDAAQ;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO,4BAA4B,sDAAM;AACzC,kCAAkC,iCAAiC;AACnE,CAAC;AACM,yBAAyB,sDAAM;AACtC,kCAAkC,gCAAgC;AAClE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GgF;AACnC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,uBAAuB,2DAAQ;AAC/B,yBAAyB,2DAAQ;;AAEjC,sBAAsB,2DAAQ;AAC9B,4BAA4B,2DAAQ;AACpC,uBAAuB,6DAAU;;AAExC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB;AACjB;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB;AACvB;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB;AAChB,GAAG;AACH;AACA,gBAAgB;AAChB,GAAG;AACH;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mDAAmD;AACnD,SAAS,8DAAW;AACpB;AACA,+HAA+H,eAAe;AAC9I;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;;AAElB,kBAAkB;;AAElB;AACA,aAAa,kBAAkB;AAC/B,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,iHAAiH,eAAe;AAChI;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA,gHAAgH,eAAe;AAC/H;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,OAAO,6DAAU;AACjB,4FAA4F,iBAAiB;AAC7G;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO;AACP,qDAAqD;AACrD,SAAS,8DAAW;AACpB;AACA,+HAA+H,aAAa;AAC5I;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;;AAEpB,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,EAAE,kCAAkC,EAAE;AACnD;AACA;AACA;AACA,8FAA8F,QAAQ;AACtG;AACA,SAAS,2DAAQ;AACjB,0FAA0F,eAAe;AACzG;AACA,WAAW,OAAO;;AAElB,SAAS,2DAAQ;AACjB,uFAAuF,YAAY;AACnG;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,oGAAoG,KAAK;AACzG;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,WAAW;AACzB;AACA;AACA;AACA,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,WAAW;AACzB;AACA;AACA;AACA,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,WAAW;AACzB;AACA;AACA;AACA,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,gBAAgB;AAC7B,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,iHAAiH,eAAe;AAChI;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzUA;AACA;AACA;AACgE;;AAEhE;AACA;;AAEO;AACP;AACA;AACA;AACA;AACO;AACP,EAAE,2DAAQ;;AAEV;AACA;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;;AAEP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACO,6FAA6F,mDAAI;AACjG;AACA;AACA;AACA;AACA;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAI;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD,OAAO,6DAAU,+BAA+B,IAAI;AACpD;AACA,CAAC;AACM;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxKO;;AAEA;;AAEP;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACP;AACO;AACA;AACA;AACA;AACA;;AAEA;AACA;AACP;AACO;AACA;;AAEA;;AAEP;AACA;AACA;AACA,QAAQ;AACD;AACP;;AAEO;AACA;AACA;AACA;;AAEP","file":"vendors.js","sourcesContent":["// Mobius flavor Base Library for MINA development\r\nimport { replayWithLatest, Data } from '../libs/mobius-utils.js'\r\n\r\nexport const makeThemeService = () => {\r\n  // initial current theme state when first called\r\n  const initialTheme = wx.getSystemInfoSync().theme\r\n\r\n  const themeRD = replayWithLatest(1, Data.of(initialTheme))\r\n\r\n  // update theme state when theme change happen\r\n  wx.onThemeChange(({ theme }) => {\r\n    console.log(theme)\r\n    themeRD.triggerValue(theme)\r\n  })\r\n\r\n  return {\r\n    themeRD\r\n  }\r\n}\r\n\r\nconst themeServices = {}\r\nexport const getThemeService = (scope) => {\r\n  console.log(scope, themeServices)\r\n  themeServices[scope] = themeServices[scope] || makeThemeService()\r\n  console.log(scope, themeServices)\r\n  return themeServices[scope]\r\n}\r\n","import { pipe, compose } from '../../functional.js'\r\nimport { isObject } from '../../internal.js'\r\n\r\nexport const isAtom = tar => isObject(tar) && tar.isAtom\r\n\r\n/**\r\n * !! please consider BaseMediator when add property or method to BaseAtom\r\n */\r\nexport class BaseAtom {\r\n  get isAtom () {\r\n    return true\r\n  }\r\n\r\n  pipe (...args) {\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    return compose(...args)(this)\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isMutation } from './mutation.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\n/**\r\n * @param { any } tar\r\n * @return { boolean }\r\n */\r\nexport const isData = tar => isObject(tar) && tar.isData\r\n\r\nexport class Data extends BaseAtom {\r\n  constructor (value, options = {}) {\r\n    super()\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(\r\n        `\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`\r\n      ))\r\n    }\r\n    this._options = options\r\n\r\n    if (isDatar(value)) {\r\n      this._datar = value\r\n    } else {\r\n      this._datar = Datar.of(value)\r\n    }\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  /**\r\n   * @return { 'DataAtom' } 'DataAtom'\r\n   */\r\n  get type () { return 'DataAtom' }\r\n\r\n  /**\r\n   * @return { true } true\r\n   */\r\n  get isData () { return true }\r\n\r\n  get isEmpty () { return this._datar.isEmpty }\r\n\r\n  static of (value, options = {}) {\r\n    return new Data(value, options)\r\n  }\r\n\r\n  /**\r\n   * Same as Data.of(VACUO)\r\n   *\r\n   * @return { Data }\r\n   */\r\n  static empty (options = {}) {\r\n    return new Data(Datar.empty(), options)\r\n  }\r\n\r\n  /**\r\n   * Static value of Data.\r\n   *\r\n   * @return { Datar } datar\r\n   */\r\n  get datar () { return this._datar }\r\n  /**\r\n   * Static value of Data, same as Data.datar.value.\r\n   *\r\n   * @return { any } value\r\n   */\r\n  get value () { return this._datar.value }\r\n\r\n  /**\r\n   * Steram value of Data.\r\n   *\r\n   * @param { function } consumer The consumer will be invoked by trigger method when there is a adequate value.\r\n   * @return { { unsubscribe: function } } SubscriptionController\r\n   */\r\n  subscribe (consumer) {\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param { Datar | undefined } datar\r\n   * @return { void }\r\n   */\r\n  trigger (datar) {\r\n    if (!isUndefined(datar) && !isDatar(datar)) {\r\n      throw (new TypeError('Data must be triggered with a Datar.'))\r\n    }\r\n    const _datar = datar || this.datar\r\n\r\n    if (!isEmpty(_datar)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_datar, this)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerValue (value) {\r\n    return this.trigger(Datar.of(value))\r\n  }\r\n\r\n  /**\r\n   * Change the value of Data in a stream manner.\r\n   *\r\n   * Given \"mutation\" will be **upstream** of current Data, which is different from \"beObservedBy\" method.\r\n   *\r\n   * @param { Mutation } mutation (other data ->) mutation -> current data\r\n   */\r\n  observe (mutation) {\r\n    if (!isMutation(mutation)) {\r\n      throw (new TypeError('Data can only observe a Mutation!'))\r\n    }\r\n    return mutation.subscribe((mutator, mutation) => {\r\n      this.mutate(mutator, mutation)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Change the value of Data in a stream manner.\r\n   *\r\n   * Given \"mutation\" will be **downstream** of current Data, which is different from \"observe\" method.\r\n   *\r\n   * @param { Mutation } mutation current data -> mutation (-> other data)\r\n   */\r\n  beObservedBy (mutation) {\r\n    return mutation.observe(this)\r\n  }\r\n\r\n  /**\r\n   * Change the value of Data in a static manner.\r\n   *\r\n   * take mutator-like param(convert to mutator)\r\n   *   -> run mutator with current datar & contexts\r\n   *   -> wrap and save result of mutator.run as new datar\r\n   *   -> trigger consumers with new datar & contexts\r\n   *\r\n   * @param { Mutator | Mutation | function } mutator Used to produce new value with current datar.\r\n   * @param { Mutation } mutation Provide to mutator's operation (function) as execute contexts.\r\n   * @return { Data } Data(this)\r\n   */\r\n  mutate (mutator, mutation) {\r\n    let _mutator\r\n    if (isMutator(mutator)) {\r\n      _mutator = mutator\r\n    } else if (isMutation(mutator)) {\r\n      _mutator = mutator.mutator\r\n    } else if (isFunction(mutator)) {\r\n      _mutator = Mutator.of(mutator)\r\n    } else {\r\n      throw (new TypeError(`\"mutator\" is expected to be type of \"Mutator\" | \"Mutation\" | \"Function\", but received \"${typeof mutator}\".`))\r\n    }\r\n    let _mutation\r\n    if (!mutation) {\r\n      _mutation = isMutation(mutator) ? mutator : _mutation\r\n    } else {\r\n      if (isMutation(mutation)) {\r\n        _mutation = mutation\r\n      } else {\r\n        throw (new TypeError(`\"mutation\" is expected to be type of \"Mutation\", but received \"${typeof mutation}\".`))\r\n      }\r\n    }\r\n\r\n    const _tempDatar = Datar.of(_mutator.run(this._datar, _mutation)).fill(_mutator)\r\n\r\n    // NOTE: If result of operation is TERMINATOR,\r\n    // do not update the datar or trigger the subscribers\r\n    if (!isTerminator(_tempDatar.value)) {\r\n      this._datar = _tempDatar\r\n      this.trigger()\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * @param { function } trigger Takes an internalTrigger(Function) as first parameter,\r\n   *                             invoke internalTrigger with any value will lead to\r\n   *                             Data's trigger method be triggerd with given value.\r\n   * @param { { forceWrap?: boolean } } options\r\n   * @accept ((datar -> trigger(datar)) -> controller, options)\r\n   * @accept ((value -> trigger(datar)) -> controller, { forceWrap: true })\r\n   * @return { {} } TriggerController\r\n   */\r\n  registerTrigger (trigger, options = {}) {\r\n    if (!trigger) {\r\n      throw (new TypeError(`\"trigger\" is required, but received \"${trigger}\".`))\r\n    }\r\n    if (!isFunction(trigger)) {\r\n      throw (new TypeError(`\"trigger\" is expected to be type of \"Function\", but received \"${typeof trigger}\".`))\r\n    }\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(`\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`))\r\n    }\r\n\r\n    const { forceWrap = false } = options\r\n\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isDatar(args[0]) || forceWrap) {\r\n        args[0] = Datar.of(args[0])\r\n      }\r\n      return this.trigger(...args)\r\n    }\r\n\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isData } from './data.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\n/**\r\n * @param { any } tar\r\n * @return { boolean }\r\n */\r\nexport const isMutation = tar => isObject(tar) && tar.isMutation\r\n\r\nexport class Mutation extends BaseAtom {\r\n  constructor (operation, options = {}) {\r\n    super()\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(\r\n        `\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`\r\n      ))\r\n    }\r\n    this._options = options\r\n\r\n    if (isMutator(operation)) {\r\n      this._mutator = operation\r\n    } else if (isFunction(operation)) {\r\n      this._mutator = Mutator.of(operation)\r\n    } else {\r\n      throw new TypeError(\r\n        `\"operation\" is expected to be type of \"Mutator\" | \"Function\", but received \"${typeof operation}\".`\r\n      )\r\n    }\r\n\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  /**\r\n   * @return { 'MutationAtom' } 'MutationAtom'\r\n   */\r\n  get type () { return 'MutationAtom' }\r\n\r\n  /**\r\n   * @return { true } true\r\n   */\r\n  get isMutation () { return true }\r\n\r\n  get isEmpty () { return this._mutator.isEmpty }\r\n\r\n  static of (operation, options = {}) {\r\n    return new Mutation(operation, options)\r\n  }\r\n\r\n  static empty (options = {}) {\r\n    return new Mutation(Mutator.empty(), options)\r\n  }\r\n\r\n  static ofLift (operation, options = {}) {\r\n    const { liftType: type } = options\r\n    return new Mutation(Mutator.lift(operation, { type }), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftBoth (operation, options = {}) {\r\n    return new Mutation(Mutator.liftBoth(operation), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftLeft (operation, options = {}) {\r\n    return new Mutation(Mutator.liftLeft(operation), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftRight (operation, options = {}) {\r\n    return new Mutation(Mutator.liftRight(operation), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  /**\r\n   * Static value of Mutation.\r\n   *\r\n   * @return { Mutator } mutator\r\n   */\r\n  get mutator () { return this._mutator }\r\n  /**\r\n   * @return { function } operation\r\n   */\r\n  get operation () {\r\n    if (this._options && this._options.isLifted) {\r\n      return this._options.origin_operation\r\n    } else {\r\n      return this._mutator.operation\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Steram value of Mutation.\r\n   *\r\n   * @param { function } consumer The consumer will be invoked by trigger method when there is a adequate value.\r\n   * @return { { unsubscribe: function } } SubscriptionController\r\n   */\r\n  subscribe (consumer) {\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param { Mutator | undefined } mutator\r\n   * @return { void }\r\n   */\r\n  trigger (mutator) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator)) {\r\n      throw (new TypeError('Mutation must be triggered with a Mutator.'))\r\n    }\r\n    const _mutator = mutator || this.mutator\r\n\r\n    if (!isEmpty(_mutator)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_mutator, this)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerOperation (operation) {\r\n    return this.trigger(Mutator.of(operation))\r\n  }\r\n\r\n  /**\r\n   * Change the value of Mutation in a stream manner.\r\n   *\r\n   * Given \"data\" will be **upstream** of current Mutation, which is different from \"beObservedBy\" method.\r\n   *\r\n   * @param { Mutation } mutation data -> current mutation (-> other data)\r\n   */\r\n  observe (data) {\r\n    if (!isData(data)) {\r\n      throw (new TypeError('Mutation can only observe a Data!'))\r\n    }\r\n    return data.subscribe((datar, data) => {\r\n      this.mutate(datar, data)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Change the value of Mutation in a stream manner.\r\n   *\r\n   * Given \"data\" will be **downstream** of current Mutation, which is different from \"observe\" method.\r\n   *\r\n   * @param { Mutation } mutation (other data ->) current mutation -> data\r\n   */\r\n  beObservedBy (data) {\r\n    return data.observe(this)\r\n  }\r\n\r\n  /**\r\n   * Change the value of Mutation in a static manner.\r\n   *\r\n   * take datar-like param(convert to datar)\r\n   *   -> run datar with current mutator & contexts\r\n   *   -> wrap and save result of datar.run as new mutator\r\n   *   -> trigger consumers with new mutator & contexts\r\n   *\r\n   * @param { Datar | Data | any } datar Will be the 2nd param of mutator's operation.\r\n   * @param { Data } data\r\n   * @return { Mutation } Mutation(this)\r\n   */\r\n  mutate (datar, data) {\r\n    let _datar = null\r\n    if (isDatar(datar)) {\r\n      _datar = datar\r\n    } else if (isData(datar)) {\r\n      _datar = datar.datar\r\n    } else {\r\n      _datar = Datar.of(datar)\r\n    }\r\n\r\n    if (isTerminator(_datar.value)) return this\r\n\r\n    let _data\r\n    if (!data) {\r\n      _data = isData(data) ? datar : _data\r\n    } else {\r\n      if (isData(data)) {\r\n        _data = data\r\n      } else {\r\n        throw (new TypeError(`\"data\" is expected to be type of \"Data\", but received \"${typeof data}\".`))\r\n      }\r\n    }\r\n\r\n    // NOTE: 运行效果相当于：const _tempMutator = this._mutator.fill(_datar)\r\n    // 但实际意义完全不同\r\n    const _tempMutator = Mutator.of(_datar.run(this._mutator, _data)).fill(_datar)\r\n\r\n    this._mutator = _tempMutator\r\n    this.trigger()\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * @param { function } trigger Takes an internalTrigger(Function) as first parameter,\r\n   *                             invoke internalTrigger with any value will lead to\r\n   *                             Mutation's trigger method be triggerd with given value.\r\n   * @param { { forceWrap?: boolean } } options\r\n   * @accept ((mutator -> trigger(mutator)) -> controller, options)\r\n   * @accept ((operation -> trigger(mutator)) -> controller, { forceWrap: true })\r\n   * @return { {} } TriggerController\r\n   */\r\n  registerTrigger (trigger, options = {}) {\r\n    if (!trigger) {\r\n      throw (new TypeError(`\"trigger\" is required, but received \"${trigger}\".`))\r\n    }\r\n    if (!isFunction(trigger)) {\r\n      throw (new TypeError(`\"trigger\" is expected to be type of \"Function\", but received \"${typeof trigger}\".`))\r\n    }\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(`\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`))\r\n    }\r\n\r\n    const { forceWrap = false } = options\r\n\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isMutator(args[0]) || forceWrap) {\r\n        args[0] = Mutator.of(args[0])\r\n      }\r\n      this.trigger(...args)\r\n    }\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","import { isObject } from '../../internal.js'\r\nimport { pipe, compose } from '../../functional.js'\r\n\r\nexport const isMediator = tar => isObject(tar) && tar.isMediator\r\n\r\nexport class BaseMediator {\r\n  constructor (atom) {\r\n    if (new.target === BaseMediator) {\r\n      throw new Error('BaseMediator can not be instantiated!')\r\n    }\r\n    this._atom = atom\r\n  }\r\n\r\n  /***********************************************************\r\n   *             Mediator's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get isMediator () {\r\n    return true\r\n  }\r\n\r\n  /***********************************************************\r\n   *                Atom's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get atom () {\r\n    return this._atom\r\n  }\r\n\r\n  get isAtom () {\r\n    return this._atom.isAtom\r\n  }\r\n\r\n  get isData () {\r\n    return this._atom.isData\r\n  }\r\n\r\n  get isMutation () {\r\n    return this._atom.isMutation\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._atom.isEmpty\r\n  }\r\n\r\n  get datar () {\r\n    if (this.isData) {\r\n      return this._atom.datar\r\n    } else {\r\n      throw (new TypeError('There is no \"datar\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get value () {\r\n    if (this.isData) {\r\n      return this._atom.value\r\n    } else {\r\n      throw (new TypeError('There is no \"value\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get mutator () {\r\n    if (this.isMutation) {\r\n      return this._atom.mutator\r\n    } else {\r\n      throw (new TypeError('There is no \"mutator\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  get operation () {\r\n    if (this.isMutation) {\r\n      return this._atom.operation\r\n    } else {\r\n      throw (new TypeError('There is no \"operation\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  subscribe (...args) {\r\n    return this._atom.subscribe(...args)\r\n  }\r\n\r\n  trigger (...args) {\r\n    return this._atom.trigger(...args)\r\n  }\r\n\r\n  triggerValue (...args) {\r\n    if (this.isData) {\r\n      return this._atom.triggerValue(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerValue\" method on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  triggerOperation (...args) {\r\n    if (this.isMutation) {\r\n      return this._atom.triggerOperation(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerOperation\" method on Data instance.'))\r\n    }\r\n  }\r\n\r\n  observe (...args) {\r\n    return this._atom.observe(...args)\r\n  }\r\n\r\n  beObservedBy (...args) {\r\n    return this._atom.beObservedBy(...args)\r\n  }\r\n\r\n  mutate (...args) {\r\n    return this._atom.mutate(...args)\r\n  }\r\n\r\n  registerTrigger (...args) {\r\n    return this._atom.registerTrigger(...args)\r\n  }\r\n\r\n  pipe (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.pipe(...args)\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.compose(...args)\r\n    return compose(...args)(this)\r\n  }\r\n\r\n  release () {\r\n    this._atom = null\r\n  }\r\n}\r\n","import { isObject, isNumber } from '../../internal.js'\r\nimport { isAtom } from '../atom.js'\r\nimport { BaseMediator } from './base.mediators.js'\r\nimport { curryN } from '../../functional.js'\r\n\r\nexport const isReplayMediator = tar => isObject(tar) && tar.isReplayMediator\r\n\r\nexport class ReplayMediator extends BaseMediator {\r\n  constructor (atom, replayTime = 1) {\r\n    super(atom)\r\n    this._history = []\r\n    this._consumers = []\r\n    this.setReplayTime(replayTime)\r\n    this._subscribeController = atom.subscribe(val => {\r\n      this._history.push(val)\r\n      this._setHistory()\r\n    })\r\n  }\r\n\r\n  get type () {\r\n    return 'ReplayMediator'\r\n  }\r\n\r\n  get isReplayMediator () {\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * @param options Number | Object\r\n   */\r\n  static of (atom, options) {\r\n    if (!isAtom(atom)) {\r\n      throw (new TypeError('ReplayMediator can apply to an Atom only.'))\r\n    }\r\n    if (isReplayMediator(atom)) {\r\n      return atom\r\n    }\r\n\r\n    let _options = {}\r\n    if (isNumber(options)) {\r\n      _options.replayTime = options\r\n    } else if (isObject(options)) {\r\n      _options = {\r\n        ..._options,\r\n        ...options\r\n      }\r\n    } else {\r\n      throw new TypeError(`\"options\" argument of ReplayMediator is expected to be type of \"Number\" | \"Object\", but received ${typeof options}.`)\r\n    }\r\n\r\n    const { replayTime, autoTrigger = true } = _options\r\n\r\n    const _mediator = new ReplayMediator(atom, replayTime)\r\n\r\n    if (autoTrigger) {\r\n      atom.trigger()\r\n    }\r\n    return _mediator\r\n  }\r\n\r\n  setReplayTime (replayTime) {\r\n    if (!isNumber(replayTime)) {\r\n      throw (new TypeError('repalyTime is expected to be a Number.'))\r\n    }\r\n    this._replayTime = Math.floor(Math.abs(replayTime))\r\n    this._setHistory()\r\n  }\r\n\r\n  _setHistory () {\r\n    const t = this._history.length - this._replayTime\r\n    this._history = this._history.slice(t >= 0 ? t : 0)\r\n  }\r\n\r\n  replayTo (consumer) {\r\n    this._history.forEach(val => {\r\n      consumer(val)\r\n    })\r\n  }\r\n\r\n  replay () {\r\n    this._consumers.forEach((consumer) => {\r\n      this.replayTo(consumer)\r\n    })\r\n  }\r\n\r\n  subscribe (consumer) {\r\n    this._consumers.push(consumer)\r\n    const subscribeController = this._atom.subscribe(consumer)\r\n    this.replayTo(consumer)\r\n    return subscribeController\r\n  }\r\n\r\n  // NOTE: important!!!\r\n  // !!! important\r\n  beObservedBy (...args) {\r\n    return args[0].observe(this)\r\n  }\r\n\r\n  release () {\r\n    this._subscribeController.unsubscribe()\r\n    super.release()\r\n  }\r\n}\r\n\r\nexport const replayWithoutLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: false })\r\n})\r\nexport const replayWithLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: true })\r\n})\r\n","import { isUndefined, isString, isObject, isFunction } from '../internal/base.js'\r\nimport { looseCurryN } from '../functional.js'\r\n\r\n/**\r\n *    Metas\r\n * Void       -> Void's role in Atom world is same as undefined & null 's role in normal JavaScript world.\r\n *               It is designed to replace values that can be converted to false, such as undefined & null.\r\n *               So falsy values can flowing through the Atoms as normal values flowing.\r\n *               For the typical usages, please check nilToVoidT & defaultT.\r\n * Terminator -> Terminator is designed as a signal for \"interruption\" of Atom Flow.\r\n *               Mutation will not mutate(trigger an operation to update the downstream data's value)\r\n *                 a Data or Datar which value is Terminator.\r\n *               Data will not mutate(update own value to income operation's result) a Mutation or Mutator or Operation\r\n *                 which result is Terminator.\r\n *               For the typical usages, please check filterT or skipT or takeT.\r\n * Vacuo      -> A value that can serve as the value (for Datar, or operation for Mutator)\r\n *                 of Datar and Mutator at the same time.\r\n * Datar      -> Designed to carry the value of Data.\r\n * Mutator    -> Designed to carry the operation of Mutation.\r\n */\r\n\r\nexport const isDatar = tar => isObject(tar) && tar.isDatar\r\nexport const isMutator = tar => isObject(tar) && tar.isMutator\r\n\r\nexport const isVoid = tar => isObject(tar) && tar.isVoid\r\nexport const isTerminator = tar => isObject(tar) && tar.isTerminator\r\nexport const isVacuo = tar => isFunction(tar) && tar.isVacuo\r\n\r\n/**\r\n *—————————————————————————————————————————————— Nothing Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n *\r\n */\r\nexport class Void {\r\n  get isVoid () { return true }\r\n}\r\nexport const VOID = new Void()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Terminator Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n *\r\n */\r\nexport class Terminator {\r\n  get isTerminator () { return true }\r\n}\r\nexport const TERMINATOR = new Terminator()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Vacuo Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n * 利用 JavaScript Function is also an Object 的特性，\r\n * 使 Vacuo 既能够作为 Datar.of() 也能作为 Mutator.of() 的参数，\r\n * 从而实现 Empty Datar 和 Empty Mutator。\r\n *\r\n * 因为要兼容浏览器扩展的执行环境，所以 class Vacuo extends Function 语法无法使用\r\n *   -> Refer: https://developer.chrome.com/docs/apps/contentSecurityPolicy/\r\n */\r\nexport const Vacuo = () => {\r\n  const internalVacuo = function () {}\r\n  Object.defineProperty(internalVacuo, 'isVacuo', {\r\n    get: () => { return true }\r\n  })\r\n  Object.defineProperty(internalVacuo, 'isEmpty', {\r\n    get: () => { return true }\r\n  })\r\n  return internalVacuo\r\n}\r\nexport const VACUO = Vacuo()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Datar Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n *\r\n */\r\nexport class Datar {\r\n  constructor (value, mutator = VACUO, options = {}) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError(\r\n        `The 2nd parameter of Datar's constructor is expected to be type of \"Mutator\" | \"Vacuo\" | \"Undefined\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n\r\n    this._options = options\r\n\r\n    this.value = value\r\n    this.mutator = mutator\r\n  }\r\n\r\n  static of (value, mutator = undefined, options = {}) {\r\n    return new Datar(value, mutator, options)\r\n  }\r\n\r\n  static empty () {\r\n    return new Datar(VACUO)\r\n  }\r\n\r\n  get isDatar () { return true }\r\n\r\n  get isEmpty () { return isVacuo(this.value) }\r\n\r\n  /**\r\n   * @param { Mutator | Vacuo } mutator\r\n   * @return { Datar } this(Datar)\r\n   */\r\n  fill (mutator) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError(\r\n        `The 1st parameter of Datar's fill method is expected to be type of \"Mutator\" | \"Vacuo\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n    this.mutator = mutator\r\n    return this\r\n  }\r\n\r\n  fillEmpty () {\r\n    this.mutator = VACUO\r\n    return this\r\n  }\r\n\r\n  fillAuto (mutator = VACUO) {\r\n    return this.fill(mutator)\r\n  }\r\n\r\n  /**\r\n   * Rarely used, this method exists to ensure the symmetry of Datar and Mutator.\r\n   *\r\n   * @param { Mutator | Vacuo } mutator default to VACUO\r\n   * @return { function | Vacuo } operation function | Vacuo\r\n   */\r\n  run (mutator = VACUO, ...args) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError(\r\n        `The 1st parameter of Datar's run method is expected to be type of \"Mutator\" | \"Vacuo\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n    // return operation or vacuo\r\n    return isMutator(mutator) ? mutator.operation : mutator\r\n  }\r\n}\r\n\r\n/**\r\n *—————————————————————————————————————————————— Mutator Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n * @param { any } operation\r\n */\r\nconst checkOperation = operation => {\r\n  if (!isFunction(operation)) {\r\n    throw (new TypeError(`\"operation\" is expected to be type of \"Function\", but received \"${typeof operation}\".`))\r\n  }\r\n}\r\n/**\r\n * @param { any } tar\r\n * @return { boolean } true | false\r\n */\r\nconst isValidOperationTarget = tar => isDatar(tar) || isVacuo(tar)\r\n/**\r\n *\r\n */\r\nexport class Mutator {\r\n  constructor (operation, datar = VACUO, options = {}) {\r\n    if (!isUndefined(datar) && !isValidOperationTarget(datar)) {\r\n      throw (new TypeError(\r\n        `The 2nd parameter of Mutator's constructor is expected to be type of \"Datar\" | \"Vacuo\" | \"Undefined\", but received \"${typeof datar}\".`\r\n      ))\r\n    }\r\n    checkOperation(operation)\r\n\r\n    this._options = options\r\n\r\n    this.operation = operation\r\n    this.datar = datar\r\n  }\r\n\r\n  static of (operation, datar = undefined, options = {}) {\r\n    return new Mutator(operation, datar, options)\r\n  }\r\n\r\n  static empty () {\r\n    return new Mutator(VACUO)\r\n  }\r\n\r\n  get isMutator () { return true }\r\n\r\n  get isEmpty () { return isVacuo(this.operation) }\r\n\r\n  static checkOperation (operation) {\r\n    checkOperation(operation)\r\n  }\r\n\r\n  static isValidOpTar (tar) {\r\n    return isValidOperationTarget(tar)\r\n  }\r\n\r\n  static isValidOperationTarget (tar) {\r\n    return isValidOperationTarget(tar)\r\n  }\r\n\r\n  /**\r\n   * Dispatch opration to correct lift method according to the given options.\r\n   *\r\n   * @param { function } operation\r\n   * @param { { type: 'both' | 'left' | 'right' } } options\r\n   */\r\n  static lift (operation, options) {\r\n    if (!options) {\r\n      throw (new TypeError(`\"options\" is required for lift method of Mutator, but received \"${options}\".`))\r\n    }\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(`\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`))\r\n    }\r\n    const { type } = options\r\n\r\n    if (!isString(type)) {\r\n      throw (new TypeError(`\"type\" is expected to be type of \"String\", but received \"${typeof type}\".`))\r\n    }\r\n\r\n    if (type === 'both') {\r\n      return this.liftBoth(operation)\r\n    } else if (type === 'left') {\r\n      return this.liftLeft(operation)\r\n    } else if (type === 'right') {\r\n      return this.liftRight(operation)\r\n    } else {\r\n      throw (new TypeError(`\"type\" is expected be one of \"both\" | \"left\" | \"right\", but received \"${type}\".`))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Automatically unwrap both left & right param to value.\r\n   *\r\n   * @param { function } operation\r\n   * @return { function } curried function(2, loose)\r\n   */\r\n  static liftBoth (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOperationTarget(prevDatar) ? prevDatar.value : prevDatar,\r\n        isValidOperationTarget(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Automatically unwrap left param to value， keep right param Datar.\r\n   *\r\n   * @param { function } operation\r\n   * @return { function } curried function(2, loose)\r\n   */\r\n  static liftLeft (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOperationTarget(prevDatar) ? prevDatar.value : prevDatar,\r\n        datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Automatically unwrap right param to value， keep left param Datar.\r\n   *\r\n   * @param { function } operation\r\n   * @return { function } curried function(2, loose)\r\n   */\r\n  static liftRight (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        prevDatar,\r\n        isValidOperationTarget(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @param { Datar | Vacuo } mutator\r\n   * @return { Mutator } this(Mutator)\r\n   */\r\n  fill (datar) {\r\n    if (!isValidOperationTarget(datar)) {\r\n      throw (new TypeError(\r\n        `The 1st parameter of Mutator's fill method is expected to be type of \"Datar\" | \"Vacuo\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n    this.datar = datar\r\n    return this\r\n  }\r\n\r\n  fillEmpty () {\r\n    this.datar = VACUO\r\n    return this\r\n  }\r\n\r\n  fillAuto (datar = VACUO) {\r\n    return this.fill(datar)\r\n  }\r\n\r\n  /**\r\n   * Atom Flow: Data A -> Mutation -> Data B\r\n   *\r\n   *   -> Data A is observed by Mutation, Mutation is observed by Data B;\r\n   *\r\n   *   -> Data A emits a datar, Mutation takes that datar as the 1st parameter of operation;\r\n   *\r\n   *   -> Mutation takes datar from Data A, then emits a mutator, Data B will take that mutator;\r\n   *\r\n   *   -> Data B takes mutator from Mutation, then pass its own datar to that mutator's operation as the 2nd parameter;\r\n   *\r\n   *   -> The operation evaluates while it has both two parameters, the result will be wrapped in a new datar;\r\n   *\r\n   *   -> The new datar will be the new datar of Data B.\r\n   *\r\n   * @param { Datar | Vacuo } datar default to VACUO\r\n   * @return { any }\r\n   */\r\n  run (datar = VACUO, ...args) {\r\n    // 保证 Mutator 的 operation 接收到的两个必要参数都是合法的操作对象\r\n    return this.operation(this.datar, isValidOperationTarget(datar) ? datar : Datar.of(datar), ...args)\r\n  }\r\n}\r\n","// use '../internal/base.js' instead of '../internal.js' to avoid ↓\r\n//   - ReferenceError: Cannot access '***' before initialization\r\n//   - because some of internal modules import the \"../functional.js\"\r\nimport { asIs, isObject, isFunction } from '../internal/base.js'\r\n\r\n// NOTE: 重复实现了 boolean.js 中的 complement 以避免循环引用\r\nconst _complement = fn => compose(x => !x, fn)\r\n\r\nexport const argPlaceholder = {\r\n  // compatible with ramda.js\r\n  '@@functional/placeholder': true,\r\n  isArgPlaceholder: true\r\n}\r\nexport const isArgPlaceholder = placeholder =>\r\n  isObject(placeholder) && Object.prototype.hasOwnProperty.call(placeholder, 'isArgPlaceholder') && placeholder.isArgPlaceholder\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const looseCurryS = (fn, ...args) => {\r\n  if (args.length >= fn.length) {\r\n    return fn(...args)\r\n  } else {\r\n    return (...args2) => looseCurryS(fn, ...args, ...args2)\r\n  }\r\n}\r\nexport const curryS = (fn, ...args) => {\r\n  const targetNum = fn.length\r\n  if (args.length >= targetNum) {\r\n    return fn(...args.slice(0, targetNum))\r\n  } else {\r\n    return (...args2) => curryS(fn, ...args, ...args2)\r\n  }\r\n}\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalLooseCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurry(fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const looseCurry = (fn, ...args) => internalLooseCurry(fn, [], ...args)\r\nexport const internalCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...extraArgs) => internalCurry(fn, validArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const curry = (fn, ...args) => internalCurry(fn, [], ...args)\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgs = innerArgs.slice(0, n)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= n) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...args2) => internalCurryN(n, fn, validArgs, ...args2)\r\n  }\r\n}\r\nexport const curryN = (n, fn, ...args) => internalCurryN(n, fn, [], ...args)\r\n// export const curry1 = (fn, ...args) => internalCurryN(1, fn, [], ...args) // just for consistency\r\n// export const curry2 = (fn, ...args) => internalCurryN(2, fn, [], ...args)\r\n// ...\r\nexport const internalLooseCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgsLen = innerArgs.slice(0, n).filter(_complement(isArgPlaceholder)).length\r\n  if (validArgsLen >= n) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurryN(n, fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\n/**\r\n * @return { function | any }\r\n */\r\nexport const looseCurryN = (n, fn, ...args) => internalLooseCurryN(n, fn, [], ...args)\r\n\r\n// NOTE: 另外一种 compose 实现\r\n// @see: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n// const compose = (...args) => value => args.reduceRight((acc, fn) => fn(acc), value)\r\n// 本质是一个闭包，直觉上不喜欢（虽然能够带来一些调试上的好处）\r\n//   -> @see: https://www.freecodecamp.org/news/pipe-and-compose-in-javascript-5b04004ac937/\r\n// 下面这种更符合函数式思维，实现上更接近数学定义\r\nexport const composeL = (...fns) => fns.reduce((g, f) => (...args) => f(g(...args)), fns.shift() || asIs)\r\nexport const composeR = (...fns) => composeL(...fns.reverse())\r\nexport const pipeL = composeR\r\nexport const pipeR = composeL\r\nexport const compose = composeR\r\nexport const pipe = composeL\r\n\r\nexport const memorize = (fn, hasher) => {\r\n  const cache = {}\r\n  hasher = hasher || ((...args) => JSON.stringify(args))\r\n  return (...args) => {\r\n    const hash = hasher(args)\r\n    if (!cache[hash]) {\r\n      cache[hash] = fn.apply(this, args)\r\n    }\r\n    return cache[hash]\r\n  }\r\n}\r\n\r\nconst invokerFactory = curryFn => (n, key) => curryFn(n, (...args) => {\r\n  // curry function controlls how many args will be passed in\r\n  const target = args[args.length - 1]\r\n  if (!target[key]) throw Error(`Can not find \"${key}\" method in target.'`)\r\n  if (!isFunction(target[key])) throw Error(`\"${key}\" property in target is not a function.`)\r\n  return target[key](...args.slice(0, args.length - 1))\r\n})\r\nexport const invoker = invokerFactory(curryN)\r\nexport const looseInvoker = invokerFactory(looseCurryN)\r\n\r\nexport const nAry = curry((n, fn) => curryN(n, fn))\r\nexport const looseNAry = curry((n, fn) => looseCurryN(n, fn))\r\nexport const binary = fn => curry((x, y) => fn(x, y)) // nAry(2, fn)\r\nexport const looseBinary = fn => looseCurry((x, y, ...args) => fn(x, y, ...args)) // looseNAry(2, fn)\r\nexport const unary = fn => x => fn(x)\r\nexport const looseUnary = fn => (x, ...args) => fn(x, ...args)\r\n\r\nexport const tap = fn => (...args) => {\r\n  fn(...args)\r\n  return args[0]\r\n}\r\n/*\r\n                  arguments num controller & curry test\r\n*/\r\n// const add = (x, y, z) => { console.log(x, y, z) }\r\n// unary(add)(1, 2, 3) // 1, undefined, undefined\r\n// binary(add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(1, add)(1, 2, 3) // 1, undefined, undefined\r\n// nAry(2, add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(3, add)(1, 2, 3) // 1, 2, 3\r\n// looseUnary(add)(1, 2, 3) // 1, 2, 3\r\n// looseBinary(add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(1, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(2, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(3, add)(1, 2, 3) // 1, 2, 3\r\n\r\n// const gg = (a, b) => {\r\n//   console.warn(a, b)\r\n// }\r\n\r\n// const ff = (a, b) => {\r\n//   curry(gg)(a)\r\n// }\r\n\r\n// ff(1)\r\n","export const isDefined = variable => typeof variable !== 'undefined'\r\n\r\nexport const isGeneralObject = tar => typeof tar === 'object'\r\n\r\n// @see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types\r\nexport const isBoolean = boo => Object.prototype.toString.call(boo) === '[object Boolean]'\r\nexport const isString = str => Object.prototype.toString.call(str) === '[object String]'\r\nexport const isNumber = num => Object.prototype.toString.call(num) === '[object Number]'\r\nexport const isSymbol = symbol => Object.prototype.toString.call(symbol) === '[object Symbol]'\r\nexport const isUndefined = val => Object.prototype.toString.call(val) === '[object Undefined]'\r\nexport const isNull = val => Object.prototype.toString.call(val) === '[object Null]'\r\nexport const isFunction = fn => fn && Object.prototype.toString.call(fn) === '[object Function]'\r\nexport const isDate = date =>\r\n  date && Object.prototype.toString.call(new Date(date)) === '[object Date]' && !!new Date(date).getTime()\r\nexport const isObject = obj => Object.prototype.toString.call(obj) === '[object Object]'\r\nexport const isArray = arr => Object.prototype.toString.call(arr) === '[object Array]'\r\nexport const isMap = map => Object.prototype.toString.call(map) === '[object Map]'\r\nexport const isWeakMap = weakMap => Object.prototype.toString.call(weakMap) === '[object WeakMap]'\r\nexport const isSet = set => Object.prototype.toString.call(set) === '[object Set]'\r\nexport const isWeakSet = weakSet => Object.prototype.toString.call(weakSet) === '[object WeakSet]'\r\nexport const isRegExp = regex => Object.prototype.toString.call(regex) === '[object RegExp]'\r\nexport const isPromise = obj => Object.prototype.toString.call(obj) === '[object Promise]'\r\nexport const isAsyncFn = fn => Object.prototype.toString.call(fn) === '[object AsyncFunction]'\r\nexport const isGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object GeneratorFunction]'\r\nexport const isAsyncGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object AsyncGeneratorFunction]'\r\nexport const isError = err => Object.prototype.toString.call(err) === '[object Error]'\r\nexport const isEmptyStr = str => isString(str) && str.length === 0\r\nexport const isEmptyArr = arr => isArray(arr) && arr.length === 0\r\nexport const isEmptyObj = obj => isObject(obj) && Object.keys(obj).length === 0\r\nexport const isOutDated = date => isDate(date) && new Date(date).getTime() < new Date().getTime()\r\n\r\nexport const isWindow = obj => Object.prototype.toString.call(obj) === '[object Window]'\r\nexport const isDocument = obj => Object.prototype.toString.call(document) === '[object HTMLDocument]'\r\n// refer: https://developer.mozilla.org/zh-CN/docs/Web/API/Event\r\nexport const isEventTarget = obj => obj instanceof EventTarget\r\nexport const isIterable = tar => Object.prototype.toString.call(tar[Symbol.iterator]) === 'object Function'\r\n\r\nexport const isObservable = obj => isObject(obj) && (obj.isObservable || isFunction(obj.subscribe))\r\n\r\n// - `null` and `undefined` are considered empty values\r\n// - `''` is the empty value for String\r\n// - `[]` is the empty value for Array\r\n// - `{}` is the empty value for Object\r\nexport const isEmpty = val =>\r\n  isNull(val) || isUndefined(val) || isEmptyStr(val) || isEmptyArr(val) || isEmptyObj(val) || (isObject(val) && val.isEmpty)\r\n\r\nexport const asIs = v => v\r\nexport const asUndefined = v => undefined\r\nexport const asNull = v => null\r\nexport const noop = v => {}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n"],"sourceRoot":""}