{"version":3,"sources":["webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/base.atom.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/data.atom.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/mutation.atom.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/base.mediator.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/replay.mediator.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/meta.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/functional/helpers.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/internal/base.js","webpack://template/webpack/bootstrap","webpack://template/webpack/runtime/define property getters","webpack://template/webpack/runtime/hasOwnProperty shorthand","webpack://template/webpack/runtime/make namespace object","webpack://template/./src/mina/app.js"],"names":["author","replayWithLatest","Data","App","onLaunch","options","console","log","subscribe","value","warn","onShow","onHide","onError","msg","globalData","appInstance","getApp"],"mappings":";;;;;;;;;;;;;;;;;AAAmD;AACP;;AAErC,sBAAsB,sDAAQ;;AAErC;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA,WAAW,oDAAI;AACf;;AAEA;AACA,WAAW,uDAAO;AAClB;AACA;;;;;;;;;;;;;;;;;;;;ACpB8E;AACD;AAC9B;AACN;;AAElC,sBAAsB,sDAAQ;;AAE9B,mBAAmB,mDAAQ;AAClC;AACA;AACA,QAAQ,iDAAO;AACf;AACA,KAAK;AACL,oBAAoB,8CAAQ;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iDAAW;AAC/B;;AAEA;AACA,gBAAgB;AAChB,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,yDAAW,YAAY,iDAAO;AACvC;AACA;AACA;AACA,SAAS,qDAAO;AAChB;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,wBAAwB,8CAAQ;AAChC;;AAEA;AACA;AACA,SAAS,6DAAU;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAS;AACjB;AACA,KAAK,UAAU,6DAAU;AACzB;AACA,KAAK,UAAU,wDAAU;AACzB,iBAAiB,gDAAU;AAC3B,KAAK;AACL;AACA;;AAEA,uBAAuB,8CAAQ;;AAE/B;AACA;AACA,SAAS,sDAAY;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,oBAAoB,KAAK;AACtD;AACA,WAAW,iDAAO;AAClB,kBAAkB,8CAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClI8E;AACD;AACtC;AACE;;AAElC,0BAA0B,sDAAQ;;AAElC,uBAAuB,mDAAQ;AACtC;AACA;AACA;AACA;AACA,QAAQ,mDAAS;AACjB;AACA,KAAK,UAAU,wDAAU;AACzB,sBAAsB,gDAAU;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mDAAa;AACrC;;AAEA;AACA,wBAAwB,kDAAY,uBAAuB,8CAA8C;AACzG;;AAEA;AACA,wBAAwB,sDAAgB,cAAc,8CAA8C;AACpG;;AAEA;AACA,wBAAwB,sDAAgB,cAAc,8CAA8C;AACpG;;AAEA;AACA,wBAAwB,uDAAiB,cAAc,8CAA8C;AACrG;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,yDAAW,cAAc,mDAAS;AAC3C;AACA;AACA;AACA,SAAS,qDAAO;AAChB;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,wBAAwB,gDAAU;AAClC;;AAEA;AACA;AACA,SAAS,qDAAM;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAO;AACf;AACA,KAAK,UAAU,qDAAM;AACrB;AACA,KAAK;AACL,eAAe,8CAAQ;AACvB;;AAEA,QAAQ,sDAAY;;AAEpB;AACA;AACA,yBAAyB,gDAAU;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,oBAAoB,KAAK;AACtD;AACA,WAAW,mDAAS;AACpB,kBAAkB,gDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/J4C;AACO;;AAE5C,0BAA0B,sDAAQ;;AAElC;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oDAAI;AACf;;AAEA;AACA;AACA;AACA,WAAW,uDAAO;AAClB;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpIsD;AACnB;AACc;AACL;;AAErC,gCAAgC,sDAAQ;;AAExC,6BAA6B,2DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,gDAAM;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,sDAAQ;AAChB;AACA,KAAK,UAAU,sDAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA,WAAW,kCAAkC;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,sDAAQ;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO,4BAA4B,sDAAM;AACzC,kCAAkC,iCAAiC;AACnE,CAAC;AACM,yBAAyB,sDAAM;AACtC,kCAAkC,gCAAgC;AAClE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGsE;AACzB;;AAE9C;AACA;AACA;AACA;AACA;;AAEO,uBAAuB,2DAAQ;AAC/B,yBAAyB,2DAAQ;;AAEjC,sBAAsB,2DAAQ;AAC9B,4BAA4B,2DAAQ;AACpC,uBAAuB,6DAAU;;AAExC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;;AAEP;AACA;AACA;AACO;AACP;AACA,SAAS,8DAAW;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,6DAAU;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,SAAS,8DAAW;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;;AAElB;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,qGAAqG,KAAK;AAC1G;AACA;;AAEA;AACA;AACA;AACA,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtNA;AACA;AACA;AACgE;;AAEhE;AACA;;AAEO;AACP;AACA;AACA;AACA;AACO;AACP,EAAE,2DAAQ;;AAEV;AACA;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;;AAEP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACO,6FAA6F,mDAAI;AACjG;AACA;AACA;AACA;AACA;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAI;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD,OAAO,6DAAU,+BAA+B,IAAI;AACpD;AACA,CAAC;AACM;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrKO;;AAEP;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACP;AACO;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEP;AACA;AACA;AACA,QAAQ;AACD;AACP;;AAEO;AACA;AACA;AACA;;AAEP;;;;;;;UChDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;ACNA;AACA;AACA;AAEA,MAAMA,MAAM,GAAGC,6DAAgB,CAAC,CAAD,EAAIC,gDAAA,CAAQ,SAAR,CAAJ,CAA/B,C,CAEA;;AACAC,GAAG,CAAC;AACFC,UAAQ,CAAEC,OAAF,EAAW;AACjBC,WAAO,CAACC,GAAR,CAAY,aAAZ;AACAP,UAAM,CAACQ,SAAP,CAAiB,CAAC;AAAEC;AAAF,KAAD,KAAe;AAC9BH,aAAO,CAACI,IAAR,CAAaD,KAAb;AACD,KAFD,EAFiB,CAKjB;AACD,GAPC;;AAQFE,QAAM,CAAEN,OAAF,EAAW,CACf;AACD,GAVC;;AAWFO,QAAM,GAAI,CACR;AACD,GAbC;;AAcFC,SAAO,CAAEC,GAAF,EAAO;AACZR,WAAO,CAACC,GAAR,CAAYO,GAAZ;AACD,GAhBC;;AAiBFC,YAAU,EAAE;AAjBV,CAAD,CAAH,C,CAoBA;;AACA,MAAMC,WAAW,GAAGC,MAAM,EAA1B;AACAX,OAAO,CAACC,GAAR,CAAYS,WAAW,CAACD,UAAxB,E,CAAoC,mB","file":"app.js","sourcesContent":["import { pipe, compose } from '../../functional.js'\r\nimport { isObject } from '../../internal.js'\r\n\r\nexport const isAtom = tar => isObject(tar) && tar.isAtom\r\n\r\n/**\r\n * !! please consider BaseMediator when add property or method to BaseAtom\r\n */\r\nexport class BaseAtom {\r\n  get isAtom () {\r\n    return true\r\n  }\r\n\r\n  pipe (...args) {\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    return compose(...args)(this)\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isMutation } from './mutation.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\nexport const isData = tar => isObject(tar) && tar.isData\r\n\r\nexport class Data extends BaseAtom {\r\n  constructor (value) {\r\n    super()\r\n    if (isDatar(value)) {\r\n      this._datar = value\r\n    } else {\r\n      this._datar = Datar.of(value)\r\n    }\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  get type () {\r\n    return 'DataAtom'\r\n  }\r\n\r\n  get isData () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._datar.isEmpty\r\n  }\r\n\r\n  static of (value) {\r\n    return new Data(value)\r\n  }\r\n\r\n  // Data.empty() <=> Data.of(VACUO)\r\n  static empty () {\r\n    return new Data(Datar.empty())\r\n  }\r\n\r\n  // Data 常规值\r\n  get datar () { return this._datar }\r\n  get value () { return this._datar.value }\r\n\r\n  // Data 流式值\r\n  // consumer:: a -> ()\r\n  // subscribe :: (a -> ()) -> SubscribeController\r\n  subscribe (consumer) {\r\n    // 维护 consumer 列表\r\n    // 保证数据 mutate 之后 notify/trigger consumer\r\n    // unsubscribe 机制\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  trigger (datar) {\r\n    if (!isUndefined(datar) && !isDatar(datar)) {\r\n      throw (new TypeError('Data must be triggered with a Datar.'))\r\n    }\r\n    const _datar = datar || this.datar\r\n    if (!isEmpty(_datar)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_datar)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerValue (value) {\r\n    return this.trigger(Datar.of(value))\r\n  }\r\n\r\n  // Data 流式变更 1\r\n  observe (mutation) {\r\n    if (!isMutation(mutation)) {\r\n      throw (new TypeError('Data can only observe a Mutation!'))\r\n    }\r\n    return mutation.subscribe(mutator => {\r\n      this.mutate(mutator)\r\n    })\r\n  }\r\n\r\n  // Data 流式变更 2\r\n  beObservedBy (mutation) {\r\n    return mutation.observe(this)\r\n  }\r\n\r\n  // Data 常规变更\r\n  // 接收 mutation -> mutation 执行数据变更 -> 保存 mutation 结果 -> 广播 mutation 结果\r\n  // mutate :: Mutation -> Data\r\n  // mutator :: Mutator -> Data\r\n  // mutate :: f -> Data\r\n  mutate (mutation) {\r\n    let _mutator = null\r\n    if (isMutator(mutation)) {\r\n      _mutator = mutation\r\n    } else if (isMutation(mutation)) {\r\n      _mutator = mutation.mutator\r\n    } else if (isFunction(mutation)) {\r\n      _mutator = Mutator.of(mutation)\r\n    } else {\r\n      throw (new TypeError('Param of \"mutate\" must be a Mutation or a Mutator or a normal Function.'))\r\n    }\r\n\r\n    const _tempDatar = Datar.of(_mutator.run(this._datar)).fill(_mutator)\r\n\r\n    // NOTE: If result of operation is TERMINATOR,\r\n    // do not update the datar or trigger the subscribers\r\n    if (!isTerminator(_tempDatar.value)) {\r\n      this._datar = _tempDatar\r\n      this.trigger()\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // registerTrigger :: ((datar -> trigger(datar)) -> controller, options) -> controller\r\n  // registerTrigger :: ((value -> trigger(mutator)) -> controller, options) -> controller\r\n  registerTrigger (trigger, { forceWrap = false } = {}) {\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isDatar(args[0]) || forceWrap) {\r\n        args[0] = Datar.of(args[0])\r\n      }\r\n      return this.trigger(...args)\r\n    }\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isData } from './data.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\nexport const isMutation = tar => isObject(tar) && tar.isMutation\r\n\r\nexport class Mutation extends BaseAtom {\r\n  // mutation 其实是一个函数\r\n  // mutation :: a -> a\r\n  constructor (operation, options) {\r\n    super()\r\n    if (isMutator(operation)) {\r\n      this._mutator = operation\r\n    } else if (isFunction(operation)) {\r\n      this._mutator = Mutator.of(operation)\r\n    } else {\r\n      throw new TypeError('Param of Mutation constructor must be a Mutator or a Function.')\r\n    }\r\n    if (options) {\r\n      this._options = options\r\n    }\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  get type () {\r\n    return 'MutationAtom'\r\n  }\r\n\r\n  get isMutation () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._mutator.isEmpty\r\n  }\r\n\r\n  // operation :: (datar, datar) -> any\r\n  // operation :: (value, datar) -> any\r\n  // operation :: (datar, value) -> any\r\n  // operation :: (value, value) -> any\r\n  static of (operation) {\r\n    return new Mutation(operation)\r\n  }\r\n\r\n  static empty () {\r\n    return new Mutation(Mutator.empty())\r\n  }\r\n\r\n  static ofLift (operation, options) {\r\n    return new Mutation(Mutator.lift(operation, options), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftBoth (operation) {\r\n    return new Mutation(Mutator.liftBoth(operation), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftLeft (operation) {\r\n    return new Mutation(Mutator.liftLeft(operation), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftRight (operation) {\r\n    return new Mutation(Mutator.liftRight(operation), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  // Mutation 常规值\r\n  get mutator () { return this._mutator }\r\n  get operation () {\r\n    if (this._options && this._options.isLifted) {\r\n      return this._options.origin_operation\r\n    } else {\r\n      return this._mutator.operation\r\n    }\r\n  }\r\n\r\n  // Mutation 流式值\r\n  // consumer :: f -> ()\r\n  // subscribe :: (f -> ()) -> SubscribeController\r\n  subscribe (consumer) {\r\n    // 维护 consumer 列表\r\n    // 保证数据 mutate 之后 notify/trigger consumer\r\n    // unsubscribe 机制\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  trigger (mutator) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator)) {\r\n      throw (new TypeError('Mutation must be triggered with a Mutator.'))\r\n    }\r\n    const _mutator = mutator || this.mutator\r\n    if (!isEmpty(_mutator)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_mutator)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerOperation (operation) {\r\n    return this.trigger(Mutator.of(operation))\r\n  }\r\n\r\n  // Mutation 流式变更 1\r\n  observe (data) {\r\n    if (!isData(data)) {\r\n      throw (new TypeError('Mutation can only observe a Data!'))\r\n    }\r\n    return data.subscribe(datar => {\r\n      this.mutate(datar)\r\n    })\r\n  }\r\n\r\n  // Mutation 流式变更 2\r\n  beObservedBy (data) {\r\n    return data.observe(this)\r\n  }\r\n\r\n  // Mutation 常规变更\r\n  // mutate :: Datar -> Mutation\r\n  // mutate :: Data -> Mutation\r\n  // mutate :: Any -> Mutation\r\n  mutate (data) {\r\n    let _datar = null\r\n    if (isDatar(data)) {\r\n      _datar = data\r\n    } else if (isData(data)) {\r\n      _datar = data.datar\r\n    } else {\r\n      _datar = Datar.of(data)\r\n    }\r\n\r\n    if (isTerminator(_datar.value)) return this\r\n\r\n    // 运行效果相当于：const _tempMutator = this._mutator.fill(_datar)\r\n    // 但实际意义完全不同\r\n    const _tempMutator = Mutator.of(_datar.run(this._mutator)).fill(_datar)\r\n\r\n    this._mutator = _tempMutator\r\n    this.trigger()\r\n\r\n    return this\r\n  }\r\n\r\n  // registerTrigger :: ((mutator -> trigger(mutator)) -> controller, options) -> controller\r\n  // registerTrigger :: ((operation -> trigger(mutator)) -> controller, options) -> controller\r\n  registerTrigger (trigger, { forceWrap = false } = {}) {\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isMutator(args[0]) || forceWrap) {\r\n        args[0] = Mutator.of(args[0])\r\n      }\r\n      this.trigger(...args)\r\n    }\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","import { isObject } from '../../internal.js'\r\nimport { pipe, compose } from '../../functional.js'\r\n\r\nexport const isMediator = tar => isObject(tar) && tar.isMediator\r\n\r\nexport class BaseMediator {\r\n  constructor (atom) {\r\n    if (new.target === BaseMediator) {\r\n      throw new Error('BaseMediator can not be instantiated!')\r\n    }\r\n    this._atom = atom\r\n  }\r\n\r\n  /***********************************************************\r\n   *             Mediator's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get isMediator () {\r\n    return true\r\n  }\r\n\r\n  /***********************************************************\r\n   *                Atom's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get atom () {\r\n    return this._atom\r\n  }\r\n\r\n  get isAtom () {\r\n    return this._atom.isAtom\r\n  }\r\n\r\n  get isData () {\r\n    return this._atom.isData\r\n  }\r\n\r\n  get isMutation () {\r\n    return this._atom.isMutation\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._atom.isEmpty\r\n  }\r\n\r\n  get datar () {\r\n    if (this.isData) {\r\n      return this._atom.datar\r\n    } else {\r\n      throw (new TypeError('There is no \"datar\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get value () {\r\n    if (this.isData) {\r\n      return this._atom.value\r\n    } else {\r\n      throw (new TypeError('There is no \"value\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get mutator () {\r\n    if (this.isMutation) {\r\n      return this._atom.mutator\r\n    } else {\r\n      throw (new TypeError('There is no \"mutator\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  get operation () {\r\n    if (this.isMutation) {\r\n      return this._atom.operation\r\n    } else {\r\n      throw (new TypeError('There is no \"operation\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  subscribe (...args) {\r\n    return this._atom.subscribe(...args)\r\n  }\r\n\r\n  trigger (...args) {\r\n    return this._atom.trigger(...args)\r\n  }\r\n\r\n  triggerValue (...args) {\r\n    if (this.isData) {\r\n      return this._atom.triggerValue(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerValue\" method on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  triggerOperation (...args) {\r\n    if (this.isMutation) {\r\n      return this._atom.triggerOperation(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerOperation\" method on Data instance.'))\r\n    }\r\n  }\r\n\r\n  observe (...args) {\r\n    return this._atom.observe(...args)\r\n  }\r\n\r\n  beObservedBy (...args) {\r\n    return this._atom.beObservedBy(...args)\r\n  }\r\n\r\n  mutate (...args) {\r\n    return this._atom.mutate(...args)\r\n  }\r\n\r\n  registerTrigger (...args) {\r\n    return this._atom.registerTrigger(...args)\r\n  }\r\n\r\n  pipe (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.pipe(...args)\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.compose(...args)\r\n    return compose(...args)(this)\r\n  }\r\n\r\n  release () {\r\n    this._atom = null\r\n  }\r\n}\r\n","import { isObject, isNumber } from '../../internal.js'\r\nimport { isAtom } from '../atom.js'\r\nimport { BaseMediator } from './base.mediator.js'\r\nimport { curryN } from '../../functional.js'\r\n\r\nexport const isReplayMediator = tar => isObject(tar) && tar.isReplayMediator\r\n\r\nexport class ReplayMediator extends BaseMediator {\r\n  constructor (atom, replayTime = 1) {\r\n    super(atom)\r\n    this._history = []\r\n    this._consumers = []\r\n    this.setReplayTime(replayTime)\r\n    this._subscribeController = atom.subscribe(val => {\r\n      this._history.push(val)\r\n      this._setHistory()\r\n    })\r\n  }\r\n\r\n  get type () {\r\n    return 'ReplayMediator'\r\n  }\r\n\r\n  get isReplayMediator () {\r\n    return true\r\n  }\r\n\r\n  static of (atom, options) {\r\n    if (!isAtom(atom)) {\r\n      throw (new TypeError('ReplayMediator can apply to an Atom (Data or Mutation) only.'))\r\n    }\r\n    if (isReplayMediator(atom)) {\r\n      return atom\r\n    }\r\n\r\n    let _options = {}\r\n    if (isNumber(options)) {\r\n      _options.replayTime = options\r\n    } else if (isObject(options)) {\r\n      _options = {\r\n        ..._options,\r\n        ...options\r\n      }\r\n    }\r\n\r\n    const { replayTime, autoTrigger = false } = _options\r\n\r\n    const _mediator = new ReplayMediator(atom, replayTime)\r\n\r\n    if (autoTrigger) {\r\n      atom.trigger()\r\n    }\r\n    return _mediator\r\n  }\r\n\r\n  setReplayTime (replayTime) {\r\n    if (!isNumber(replayTime)) {\r\n      throw (new TypeError('repalyTime is expected to be a Number.'))\r\n    }\r\n    this._replayTime = Math.floor(Math.abs(replayTime))\r\n    this._setHistory()\r\n  }\r\n\r\n  _setHistory () {\r\n    const t = this._history.length - this._replayTime\r\n    this._history = this._history.slice(t >= 0 ? t : 0)\r\n  }\r\n\r\n  replayTo (consumer) {\r\n    this._history.forEach(val => {\r\n      consumer(val)\r\n    })\r\n  }\r\n\r\n  replay () {\r\n    this._consumers.forEach((consumer) => {\r\n      this.replayTo(consumer)\r\n    })\r\n  }\r\n\r\n  subscribe (consumer) {\r\n    this._consumers.push(consumer)\r\n    const subscribeController = this._atom.subscribe(consumer)\r\n    this.replayTo(consumer)\r\n    return subscribeController\r\n  }\r\n\r\n  // NOTE: important!!!\r\n  // !!! important\r\n  beObservedBy (...args) {\r\n    return args[0].observe(this)\r\n  }\r\n\r\n  release () {\r\n    this._subscribeController.unsubscribe()\r\n    super.release()\r\n  }\r\n}\r\n\r\nexport const replayWithoutLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: false })\r\n})\r\nexport const replayWithLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: true })\r\n})\r\n","import { isUndefined, isObject, isFunction } from '../internal/base.js'\r\nimport { looseCurryN } from '../functional.js'\r\n\r\n// metas\r\n// Terminator\r\n// Vacuo\r\n// Datar\r\n// Mutator\r\n\r\nexport const isDatar = tar => isObject(tar) && tar.isDatar\r\nexport const isMutator = tar => isObject(tar) && tar.isMutator\r\n\r\nexport const isVoid = tar => isObject(tar) && tar.isVoid\r\nexport const isTerminator = tar => isObject(tar) && tar.isTerminator\r\nexport const isVacuo = tar => isFunction(tar) && tar.isVacuo\r\n\r\n/**\r\n *—————————————————————————————————————————————— Nothing Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Void {\r\n  get isVoid () {\r\n    return true\r\n  }\r\n}\r\nexport const VOID = new Void()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Terminator Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Terminator {\r\n  get isTerminator () {\r\n    return true\r\n  }\r\n}\r\nexport const TERMINATOR = new Terminator()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Vacuo Particle ————————————————————————————————————————————————————\r\n */\r\n//  利用 JavaScript Function is also an Object 的特性\r\n//  使 Vacuo 既能够作为 Datar.of() 也能作为 Mutator.of() 的参数\r\n//    从而实现 Empty Datar 和 Empty Mutator\r\n//  https://developer.chrome.com/docs/apps/contentSecurityPolicy/\r\n//  因为要兼容浏览器扩展的执行环境，所以 class Vacuo extends Function 语法无法使用\r\nexport const Vacuo = () => {\r\n  const internalVacuo = function () {}\r\n  Object.defineProperty(internalVacuo, 'isVacuo', {\r\n    get: () => {\r\n      return true\r\n    }\r\n  })\r\n  Object.defineProperty(internalVacuo, 'isEmpty', {\r\n    get: () => {\r\n      return true\r\n    }\r\n  })\r\n  return internalVacuo\r\n}\r\nexport const VACUO = Vacuo()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Datar Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Datar {\r\n  constructor (value, mutator = VACUO) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError('Only the Mutator or Vacuo type of particle is expected to be received as 2nd parameter of Datar particle constructor.'))\r\n    }\r\n    this.value = value\r\n    this.mutator = mutator\r\n  }\r\n\r\n  static of (value) {\r\n    return new Datar(value)\r\n  }\r\n\r\n  static empty () {\r\n    return new Datar(VACUO)\r\n  }\r\n\r\n  get isDatar () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return isVacuo(this.value)\r\n  }\r\n\r\n  fill (mutator) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError('Only the Mutator or Vacuo type of particle is expected to be received by \"fill\" method of Datar particle.'))\r\n    }\r\n    this.mutator = mutator\r\n    return this\r\n  }\r\n\r\n  // 很少用到，之所以存在是为了保证 Datar 和 Mutator 的对称性\r\n  run (mutator = VACUO) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError('Only the Mutator or Vacuo type of particle is expected to be received by \"run\" method of Datar particle.'))\r\n    }\r\n    return isMutator(mutator) ? mutator.operation : mutator\r\n  }\r\n}\r\n\r\nconst checkOperation = operation => {\r\n  if (!isFunction(operation)) {\r\n    throw (new TypeError('operation must be the type of Function.'))\r\n  }\r\n}\r\n// isValidOpTar(isValidOperationTarget) :: any -> Boolean\r\nconst isValidOpTar = tar => {\r\n  return isDatar(tar) || isVacuo(tar)\r\n}\r\n/**\r\n *—————————————————————————————————————————————— Mutator Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Mutator {\r\n  constructor (operation, datar = VACUO) {\r\n    if (!isUndefined(datar) && !isValidOpTar(datar)) {\r\n      throw (new TypeError('Only the Datar or Vacuo type of particle is expected to be received as 2nd parameter of Mutator particle constructor.'))\r\n    }\r\n    checkOperation(operation)\r\n    this.operation = operation\r\n    this.datar = datar\r\n  }\r\n\r\n  static of (operation) {\r\n    return new Mutator(operation)\r\n  }\r\n\r\n  static empty () {\r\n    return new Mutator(VACUO)\r\n  }\r\n\r\n  get isMutator () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return isVacuo(this.operation)\r\n  }\r\n\r\n  static checkOperation (operation) {\r\n    checkOperation(operation)\r\n  }\r\n\r\n  static isValidOpTar (tar) {\r\n    return isValidOpTar(tar)\r\n  }\r\n\r\n  // lift dispatcher\r\n  static lift (operation, options) {\r\n    const { type } = options\r\n\r\n    if (type === 'both') {\r\n      return this.liftBoth(operation)\r\n    } else if (type === 'left') {\r\n      return this.liftLeft(operation)\r\n    } else if (type === 'right') {\r\n      return this.liftRight(operation)\r\n    } else {\r\n      throw (new TypeError(`\"type\" of lift must be one of \"both\" | \"left\" | \"right\", but receives \"${type}\"`))\r\n    }\r\n  }\r\n\r\n  // Automatically unwrap both left & right param to value\r\n  static liftBoth (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOpTar(prevDatar) ? prevDatar.value : prevDatar,\r\n        isValidOpTar(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  // Automatically unwrap left param to value， keep right param Datar\r\n  static liftLeft (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOpTar(prevDatar) ? prevDatar.value : prevDatar,\r\n        datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  // Automatically unwrap right param to value， keep left param Datar\r\n  static liftRight (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        prevDatar,\r\n        isValidOpTar(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  fill (datar) {\r\n    if (!isValidOpTar(datar)) {\r\n      throw (new TypeError('Only the Datar or Vacuo type of particle is expected to be received by \"fill\" method of Mutator particle.'))\r\n    }\r\n    this.datar = datar\r\n    return this\r\n  }\r\n\r\n  run (datar = VACUO, ...args) {\r\n    // 保证 Mutator 的 operation 接收到的两个必要参数都是合法的操作对象\r\n    return this.operation(this.datar, isValidOpTar(datar) ? datar : Datar.of(datar), ...args)\r\n  }\r\n}\r\n","// use '../internal/base.js' instead of '../internal.js' to avoid ↓\r\n//   - ReferenceError: Cannot access '***' before initialization\r\n//   - because some of internal modules import the \"../functional.js\"\r\nimport { asIs, isObject, isFunction } from '../internal/base.js'\r\n\r\n// NOTE: 重复实现了 boolean.js 中的 complement 以避免循环引用\r\nconst _complement = fn => compose(x => !x, fn)\r\n\r\nexport const argPlaceholder = {\r\n  // compatible with ramda.js\r\n  '@@functional/placeholder': true,\r\n  isArgPlaceholder: true\r\n}\r\nexport const isArgPlaceholder = placeholder =>\r\n  isObject(placeholder) && Object.prototype.hasOwnProperty.call(placeholder, 'isArgPlaceholder') && placeholder.isArgPlaceholder\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const looseCurryS = (fn, ...args) => {\r\n  if (args.length >= fn.length) {\r\n    return fn(...args)\r\n  } else {\r\n    return (...args2) => curryS(fn, ...args, ...args2)\r\n  }\r\n}\r\nexport const curryS = (fn, ...args) => {\r\n  const targetNum = fn.length\r\n  if (args.length >= targetNum) {\r\n    return fn(...args.slice(0, targetNum))\r\n  } else {\r\n    return (...args2) => curryS(fn, ...args, ...args2)\r\n  }\r\n}\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalLooseCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurry(fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const looseCurry = (fn, ...args) => internalLooseCurry(fn, [], ...args)\r\nexport const internalCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...extraArgs) => internalCurry(fn, validArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const curry = (fn, ...args) => internalCurry(fn, [], ...args)\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgs = innerArgs.slice(0, n)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= n) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...args2) => internalCurryN(n, fn, validArgs, ...args2)\r\n  }\r\n}\r\nexport const curryN = (n, fn, ...args) => internalCurryN(n, fn, [], ...args)\r\n// export const curry1 = (fn, ...args) => internalCurryN(1, fn, [], ...args) // just for consistency\r\n// export const curry2 = (fn, ...args) => internalCurryN(2, fn, [], ...args)\r\n// ...\r\nexport const internalLooseCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgsLen = innerArgs.slice(0, n).filter(_complement(isArgPlaceholder)).length\r\n  if (validArgsLen >= n) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurryN(n, fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const looseCurryN = (n, fn, ...args) => internalLooseCurryN(n, fn, [], ...args)\r\n\r\n// NOTE: 另外一种 compose 实现\r\n// @see: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n// const compose = (...args) => value => args.reduceRight((acc, fn) => fn(acc), value)\r\n// 本质是一个闭包，直觉上不喜欢（虽然能够带来一些调试上的好处）\r\n//   -> @see: https://www.freecodecamp.org/news/pipe-and-compose-in-javascript-5b04004ac937/\r\n// 下面这种更符合函数式思维，实现上更接近数学定义\r\nexport const composeL = (...fns) => fns.reduce((g, f) => (...args) => f(g(...args)), fns.shift() || asIs)\r\nexport const composeR = (...fns) => composeL(...fns.reverse())\r\nexport const pipeL = composeL\r\nexport const pipeR = composeR\r\nexport const compose = composeR\r\nexport const pipe = composeL\r\n\r\nexport const memorize = (fn, hasher) => {\r\n  const cache = {}\r\n  hasher = hasher || ((...args) => JSON.stringify(args))\r\n  return (...args) => {\r\n    const hash = hasher(args)\r\n    if (!cache[hash]) {\r\n      cache[hash] = fn.apply(this, args)\r\n    }\r\n    return cache[hash]\r\n  }\r\n}\r\n\r\nconst invokerFactory = curryFn => (n, key) => curryFn(n, (...args) => {\r\n  // curry function controlls how many args will be passed in\r\n  const target = args[args.length - 1]\r\n  if (!target[key]) throw Error(`Can not find \"${key}\" method in target.'`)\r\n  if (!isFunction(target[key])) throw Error(`\"${key}\" property in target is not a function.`)\r\n  return target[key](...args.slice(0, args.length - 1))\r\n})\r\nexport const invoker = invokerFactory(curryN)\r\nexport const looseInvoker = invokerFactory(looseCurryN)\r\n\r\nexport const nAry = curry((n, fn) => curryN(n, fn))\r\nexport const looseNAry = curry((n, fn) => looseCurryN(n, fn))\r\nexport const binary = fn => curry((x, y) => fn(x, y)) // nAry(2, fn)\r\nexport const looseBinary = fn => looseCurry((x, y, ...args) => fn(x, y, ...args)) // looseNAry(2, fn)\r\nexport const unary = fn => x => fn(x)\r\nexport const looseUnary = fn => (x, ...args) => fn(x, ...args)\r\n\r\nexport const tap = fn => (...args) => {\r\n  fn(...args)\r\n  return args[0]\r\n}\r\n/*\r\n                  arguments num controller & curry test\r\n*/\r\n// const add = (x, y, z) => { console.log(x, y, z) }\r\n// unary(add)(1, 2, 3) // 1, undefined, undefined\r\n// binary(add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(1, add)(1, 2, 3) // 1, undefined, undefined\r\n// nAry(2, add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(3, add)(1, 2, 3) // 1, 2, 3\r\n// looseUnary(add)(1, 2, 3) // 1, 2, 3\r\n// looseBinary(add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(1, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(2, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(3, add)(1, 2, 3) // 1, 2, 3\r\n\r\n// const gg = (a, b) => {\r\n//   console.warn(a, b)\r\n// }\r\n\r\n// const ff = (a, b) => {\r\n//   curry(gg)(a)\r\n// }\r\n\r\n// ff(1)\r\n","export const isDefined = variable => typeof variable !== 'undefined'\r\n\r\n// @see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types\r\nexport const isBoolean = boo => Object.prototype.toString.call(boo) === '[object Boolean]'\r\nexport const isString = str => Object.prototype.toString.call(str) === '[object String]'\r\nexport const isNumber = num => Object.prototype.toString.call(num) === '[object Number]'\r\nexport const isSymbol = symbol => Object.prototype.toString.call(symbol) === '[object Symbol]'\r\nexport const isUndefined = val => Object.prototype.toString.call(val) === '[object Undefined]'\r\nexport const isNull = val => Object.prototype.toString.call(val) === '[object Null]'\r\nexport const isFunction = fn => fn && Object.prototype.toString.call(fn) === '[object Function]'\r\nexport const isDate = date =>\r\n  date && Object.prototype.toString.call(new Date(date)) === '[object Date]' && !!new Date(date).getTime()\r\nexport const isObject = obj => Object.prototype.toString.call(obj) === '[object Object]'\r\nexport const isArray = arr => Object.prototype.toString.call(arr) === '[object Array]'\r\nexport const isMap = map => Object.prototype.toString.call(map) === '[object Map]'\r\nexport const isWeakMap = weakMap => Object.prototype.toString.call(weakMap) === '[object WeakMap]'\r\nexport const isSet = set => Object.prototype.toString.call(set) === '[object Set]'\r\nexport const isWeakSet = weakSet => Object.prototype.toString.call(weakSet) === '[object WeakSet]'\r\nexport const isRegExp = regex => Object.prototype.toString.call(regex) === '[object RegExp]'\r\nexport const isPromise = obj => Object.prototype.toString.call(obj) === '[object Promise]'\r\nexport const isAsyncFn = fn => Object.prototype.toString.call(fn) === '[object AsyncFunction]'\r\nexport const isGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object GeneratorFunction]'\r\nexport const isAsyncGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object AsyncGeneratorFunction]'\r\nexport const isError = err => Object.prototype.toString.call(err) === '[object Error]'\r\nexport const isEmptyStr = str => isString(str) && str.length === 0\r\nexport const isEmptyArr = arr => isArray(arr) && arr.length === 0\r\nexport const isEmptyObj = obj => isObject(obj) && Object.keys(obj).length === 0\r\nexport const isOutDated = date => isDate(date) && new Date(date).getTime() < new Date().getTime()\r\n\r\nexport const isWindow = obj => Object.prototype.toString.call(obj) === '[object Window]'\r\nexport const isEventTarget = obj => obj instanceof EventTarget\r\n\r\nexport const isObservable = obj => isObject(obj) && (obj.isObservable || isFunction(obj.subscribe))\r\n\r\n// - `null` and `undefined` are considered empty values\r\n// - `''` is the empty value for String\r\n// - `[]` is the empty value for Array\r\n// - `{}` is the empty value for Object\r\nexport const isEmpty = val =>\r\n  isNull(val) || isUndefined(val) || isEmptyStr(val) || isEmptyArr(val) || isEmptyObj(val) || (isObject(val) && val.isEmpty)\r\n\r\nexport const asIs = v => v\r\nexport const asUndefined = v => undefined\r\nexport const asNull = v => null\r\nexport const noop = v => {}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable no-undef */\r\nimport { replayWithLatest, Data } from 'MobiusUtils'\r\nimport { html, makeComponentWithReplay } from 'MobiusUI'\r\n\r\nconst author = replayWithLatest(1, Data.of('cigaret'))\r\n\r\n// app.js\r\nApp({\r\n  onLaunch (options) {\r\n    console.log('[app lunch]')\r\n    author.subscribe(({ value }) => {\r\n      console.warn(value)\r\n    })\r\n    // Do something initial when launch.ggg\r\n  },\r\n  onShow (options) {\r\n    // Do something when show.\r\n  },\r\n  onHide () {\r\n    // Do something when hide.\r\n  },\r\n  onError (msg) {\r\n    console.log(msg)\r\n  },\r\n  globalData: 'I am global data!'\r\n})\r\n\r\n// xxx.js\r\nconst appInstance = getApp()\r\nconsole.log(appInstance.globalData) // I am global data\r\n"],"sourceRoot":""}