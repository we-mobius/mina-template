{"version":3,"sources":["webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/internal/base.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/functional/helpers.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/base.mediator.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/replay.mediator.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/base.atom.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/meta.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/mutation.atom.js","webpack://template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/data.atom.js","webpack://template/./src/mina/base/index.js","webpack://template/./src/mina/pages/me/me.js"],"names":["isNumber","num","Object","prototype","toString","call","val","fn","obj","isEmptyStr","str","isString","length","isEmptyArr","arr","isArray","isNull","keys","isEmpty","asIs","v","_complement","compose","x","isArgPlaceholder","placeholder","hasOwnProperty","internalCurry","filled","args","innerArgs","map","innerArg","shift","concat","targetNum","validArgs","slice","filter","extraArgs","curry","internalCurryN","n","args2","curryN","internalLooseCurryN","looseCurryN","composeL","fns","reduce","g","f","composeR","reverse","pipe","invokerFactory","curryFn","key","target","Error","BaseMediator","atom","this","_atom","isAtom","isData","isMutation","datar","TypeError","value","mutator","operation","subscribe","trigger","triggerValue","triggerOperation","observe","beObservedBy","mutate","registerTrigger","ReplayMediator","replayTime","super","_history","_consumers","setReplayTime","_subscribeController","push","_setHistory","options","tar","isReplayMediator","_options","autoTrigger","_mediator","_replayTime","Math","floor","abs","t","consumer","forEach","replayTo","subscribeController","unsubscribe","release","of","replayWithLatest","isDatar","isMutator","isVacuo","VACUO","internalVacuo","defineProperty","get","Vacuo","checkOperation","isValidOpTar","type","liftBoth","liftLeft","liftRight","prevDatar","Data","_datar","Set","add","delete","mutation","_mutator","_tempDatar","run","fill","isTerminator","forceWrap","themeServices","themeRD","scope","initialTheme","wx","getSystemInfoSync","theme","onThemeChange","makeThemeService","Page","data","message","onLoad","setData"],"mappings":"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","file":"pages/me/me.js","sourcesContent":["export const isDefined = variable => typeof variable !== 'undefined'\r\n\r\n// @see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types\r\nexport const isBoolean = boo => Object.prototype.toString.call(boo) === '[object Boolean]'\r\nexport const isString = str => Object.prototype.toString.call(str) === '[object String]'\r\nexport const isNumber = num => Object.prototype.toString.call(num) === '[object Number]'\r\nexport const isSymbol = symbol => Object.prototype.toString.call(symbol) === '[object Symbol]'\r\nexport const isUndefined = val => Object.prototype.toString.call(val) === '[object Undefined]'\r\nexport const isNull = val => Object.prototype.toString.call(val) === '[object Null]'\r\nexport const isFunction = fn => fn && Object.prototype.toString.call(fn) === '[object Function]'\r\nexport const isDate = date =>\r\n  date && Object.prototype.toString.call(new Date(date)) === '[object Date]' && !!new Date(date).getTime()\r\nexport const isObject = obj => Object.prototype.toString.call(obj) === '[object Object]'\r\nexport const isArray = arr => Object.prototype.toString.call(arr) === '[object Array]'\r\nexport const isMap = map => Object.prototype.toString.call(map) === '[object Map]'\r\nexport const isWeakMap = weakMap => Object.prototype.toString.call(weakMap) === '[object WeakMap]'\r\nexport const isSet = set => Object.prototype.toString.call(set) === '[object Set]'\r\nexport const isWeakSet = weakSet => Object.prototype.toString.call(weakSet) === '[object WeakSet]'\r\nexport const isRegExp = regex => Object.prototype.toString.call(regex) === '[object RegExp]'\r\nexport const isPromise = obj => Object.prototype.toString.call(obj) === '[object Promise]'\r\nexport const isAsyncFn = fn => Object.prototype.toString.call(fn) === '[object AsyncFunction]'\r\nexport const isGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object GeneratorFunction]'\r\nexport const isAsyncGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object AsyncGeneratorFunction]'\r\nexport const isError = err => Object.prototype.toString.call(err) === '[object Error]'\r\nexport const isEmptyStr = str => isString(str) && str.length === 0\r\nexport const isEmptyArr = arr => isArray(arr) && arr.length === 0\r\nexport const isEmptyObj = obj => isObject(obj) && Object.keys(obj).length === 0\r\nexport const isOutDated = date => isDate(date) && new Date(date).getTime() < new Date().getTime()\r\n\r\nexport const isWindow = obj => Object.prototype.toString.call(obj) === '[object Window]'\r\nexport const isEventTarget = obj => obj instanceof EventTarget\r\n\r\nexport const isObservable = obj => isObject(obj) && (obj.isObservable || isFunction(obj.subscribe))\r\n\r\n// - `null` and `undefined` are considered empty values\r\n// - `''` is the empty value for String\r\n// - `[]` is the empty value for Array\r\n// - `{}` is the empty value for Object\r\nexport const isEmpty = val =>\r\n  isNull(val) || isUndefined(val) || isEmptyStr(val) || isEmptyArr(val) || isEmptyObj(val) || (isObject(val) && val.isEmpty)\r\n\r\nexport const asIs = v => v\r\nexport const asUndefined = v => undefined\r\nexport const asNull = v => null\r\nexport const noop = v => {}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n","// use '../internal/base.js' instead of '../internal.js' to avoid ↓\r\n//   - ReferenceError: Cannot access '***' before initialization\r\n//   - because some of internal modules import the \"../functional.js\"\r\nimport { asIs, isObject, isFunction } from '../internal/base.js'\r\n\r\n// NOTE: 重复实现了 boolean.js 中的 complement 以避免循环引用\r\nconst _complement = fn => compose(x => !x, fn)\r\n\r\nexport const argPlaceholder = {\r\n  // compatible with ramda.js\r\n  '@@functional/placeholder': true,\r\n  isArgPlaceholder: true\r\n}\r\nexport const isArgPlaceholder = placeholder =>\r\n  isObject(placeholder) && Object.prototype.hasOwnProperty.call(placeholder, 'isArgPlaceholder') && placeholder.isArgPlaceholder\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const looseCurryS = (fn, ...args) => {\r\n  if (args.length >= fn.length) {\r\n    return fn(...args)\r\n  } else {\r\n    return (...args2) => curryS(fn, ...args, ...args2)\r\n  }\r\n}\r\nexport const curryS = (fn, ...args) => {\r\n  const targetNum = fn.length\r\n  if (args.length >= targetNum) {\r\n    return fn(...args.slice(0, targetNum))\r\n  } else {\r\n    return (...args2) => curryS(fn, ...args, ...args2)\r\n  }\r\n}\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalLooseCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurry(fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const looseCurry = (fn, ...args) => internalLooseCurry(fn, [], ...args)\r\nexport const internalCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...extraArgs) => internalCurry(fn, validArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const curry = (fn, ...args) => internalCurry(fn, [], ...args)\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgs = innerArgs.slice(0, n)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= n) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...args2) => internalCurryN(n, fn, validArgs, ...args2)\r\n  }\r\n}\r\nexport const curryN = (n, fn, ...args) => internalCurryN(n, fn, [], ...args)\r\n// export const curry1 = (fn, ...args) => internalCurryN(1, fn, [], ...args) // just for consistency\r\n// export const curry2 = (fn, ...args) => internalCurryN(2, fn, [], ...args)\r\n// ...\r\nexport const internalLooseCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgsLen = innerArgs.slice(0, n).filter(_complement(isArgPlaceholder)).length\r\n  if (validArgsLen >= n) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurryN(n, fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const looseCurryN = (n, fn, ...args) => internalLooseCurryN(n, fn, [], ...args)\r\n\r\n// NOTE: 另外一种 compose 实现\r\n// @see: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n// const compose = (...args) => value => args.reduceRight((acc, fn) => fn(acc), value)\r\n// 本质是一个闭包，直觉上不喜欢（虽然能够带来一些调试上的好处）\r\n//   -> @see: https://www.freecodecamp.org/news/pipe-and-compose-in-javascript-5b04004ac937/\r\n// 下面这种更符合函数式思维，实现上更接近数学定义\r\nexport const composeL = (...fns) => fns.reduce((g, f) => (...args) => f(g(...args)), fns.shift() || asIs)\r\nexport const composeR = (...fns) => composeL(...fns.reverse())\r\nexport const pipeL = composeL\r\nexport const pipeR = composeR\r\nexport const compose = composeR\r\nexport const pipe = composeL\r\n\r\nexport const memorize = (fn, hasher) => {\r\n  const cache = {}\r\n  hasher = hasher || ((...args) => JSON.stringify(args))\r\n  return (...args) => {\r\n    const hash = hasher(args)\r\n    if (!cache[hash]) {\r\n      cache[hash] = fn.apply(this, args)\r\n    }\r\n    return cache[hash]\r\n  }\r\n}\r\n\r\nconst invokerFactory = curryFn => (n, key) => curryFn(n, (...args) => {\r\n  // curry function controlls how many args will be passed in\r\n  const target = args[args.length - 1]\r\n  if (!target[key]) throw Error(`Can not find \"${key}\" method in target.'`)\r\n  if (!isFunction(target[key])) throw Error(`\"${key}\" property in target is not a function.`)\r\n  return target[key](...args.slice(0, args.length - 1))\r\n})\r\nexport const invoker = invokerFactory(curryN)\r\nexport const looseInvoker = invokerFactory(looseCurryN)\r\n\r\nexport const nAry = curry((n, fn) => curryN(n, fn))\r\nexport const looseNAry = curry((n, fn) => looseCurryN(n, fn))\r\nexport const binary = fn => curry((x, y) => fn(x, y)) // nAry(2, fn)\r\nexport const looseBinary = fn => looseCurry((x, y, ...args) => fn(x, y, ...args)) // looseNAry(2, fn)\r\nexport const unary = fn => x => fn(x)\r\nexport const looseUnary = fn => (x, ...args) => fn(x, ...args)\r\n\r\nexport const tap = fn => (...args) => {\r\n  fn(...args)\r\n  return args[0]\r\n}\r\n/*\r\n                  arguments num controller & curry test\r\n*/\r\n// const add = (x, y, z) => { console.log(x, y, z) }\r\n// unary(add)(1, 2, 3) // 1, undefined, undefined\r\n// binary(add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(1, add)(1, 2, 3) // 1, undefined, undefined\r\n// nAry(2, add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(3, add)(1, 2, 3) // 1, 2, 3\r\n// looseUnary(add)(1, 2, 3) // 1, 2, 3\r\n// looseBinary(add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(1, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(2, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(3, add)(1, 2, 3) // 1, 2, 3\r\n\r\n// const gg = (a, b) => {\r\n//   console.warn(a, b)\r\n// }\r\n\r\n// const ff = (a, b) => {\r\n//   curry(gg)(a)\r\n// }\r\n\r\n// ff(1)\r\n","import { isObject } from '../../internal.js'\r\nimport { pipe, compose } from '../../functional.js'\r\n\r\nexport const isMediator = tar => isObject(tar) && tar.isMediator\r\n\r\nexport class BaseMediator {\r\n  constructor (atom) {\r\n    if (new.target === BaseMediator) {\r\n      throw new Error('BaseMediator can not be instantiated!')\r\n    }\r\n    this._atom = atom\r\n  }\r\n\r\n  /***********************************************************\r\n   *             Mediator's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get isMediator () {\r\n    return true\r\n  }\r\n\r\n  /***********************************************************\r\n   *                Atom's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get atom () {\r\n    return this._atom\r\n  }\r\n\r\n  get isAtom () {\r\n    return this._atom.isAtom\r\n  }\r\n\r\n  get isData () {\r\n    return this._atom.isData\r\n  }\r\n\r\n  get isMutation () {\r\n    return this._atom.isMutation\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._atom.isEmpty\r\n  }\r\n\r\n  get datar () {\r\n    if (this.isData) {\r\n      return this._atom.datar\r\n    } else {\r\n      throw (new TypeError('There is no \"datar\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get value () {\r\n    if (this.isData) {\r\n      return this._atom.value\r\n    } else {\r\n      throw (new TypeError('There is no \"value\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get mutator () {\r\n    if (this.isMutation) {\r\n      return this._atom.mutator\r\n    } else {\r\n      throw (new TypeError('There is no \"mutator\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  get operation () {\r\n    if (this.isMutation) {\r\n      return this._atom.operation\r\n    } else {\r\n      throw (new TypeError('There is no \"operation\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  subscribe (...args) {\r\n    return this._atom.subscribe(...args)\r\n  }\r\n\r\n  trigger (...args) {\r\n    return this._atom.trigger(...args)\r\n  }\r\n\r\n  triggerValue (...args) {\r\n    if (this.isData) {\r\n      return this._atom.triggerValue(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerValue\" method on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  triggerOperation (...args) {\r\n    if (this.isMutation) {\r\n      return this._atom.triggerOperation(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerOperation\" method on Data instance.'))\r\n    }\r\n  }\r\n\r\n  observe (...args) {\r\n    return this._atom.observe(...args)\r\n  }\r\n\r\n  beObservedBy (...args) {\r\n    return this._atom.beObservedBy(...args)\r\n  }\r\n\r\n  mutate (...args) {\r\n    return this._atom.mutate(...args)\r\n  }\r\n\r\n  registerTrigger (...args) {\r\n    return this._atom.registerTrigger(...args)\r\n  }\r\n\r\n  pipe (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.pipe(...args)\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.compose(...args)\r\n    return compose(...args)(this)\r\n  }\r\n\r\n  release () {\r\n    this._atom = null\r\n  }\r\n}\r\n","import { isObject, isNumber } from '../../internal.js'\r\nimport { isAtom } from '../atom.js'\r\nimport { BaseMediator } from './base.mediator.js'\r\nimport { curryN } from '../../functional.js'\r\n\r\nexport const isReplayMediator = tar => isObject(tar) && tar.isReplayMediator\r\n\r\nexport class ReplayMediator extends BaseMediator {\r\n  constructor (atom, replayTime = 1) {\r\n    super(atom)\r\n    this._history = []\r\n    this._consumers = []\r\n    this.setReplayTime(replayTime)\r\n    this._subscribeController = atom.subscribe(val => {\r\n      this._history.push(val)\r\n      this._setHistory()\r\n    })\r\n  }\r\n\r\n  get type () {\r\n    return 'ReplayMediator'\r\n  }\r\n\r\n  get isReplayMediator () {\r\n    return true\r\n  }\r\n\r\n  static of (atom, options) {\r\n    if (!isAtom(atom)) {\r\n      throw (new TypeError('ReplayMediator can apply to an Atom (Data or Mutation) only.'))\r\n    }\r\n    if (isReplayMediator(atom)) {\r\n      return atom\r\n    }\r\n\r\n    let _options = {}\r\n    if (isNumber(options)) {\r\n      _options.replayTime = options\r\n    } else if (isObject(options)) {\r\n      _options = {\r\n        ..._options,\r\n        ...options\r\n      }\r\n    }\r\n\r\n    const { replayTime, autoTrigger = false } = _options\r\n\r\n    const _mediator = new ReplayMediator(atom, replayTime)\r\n\r\n    if (autoTrigger) {\r\n      atom.trigger()\r\n    }\r\n    return _mediator\r\n  }\r\n\r\n  setReplayTime (replayTime) {\r\n    if (!isNumber(replayTime)) {\r\n      throw (new TypeError('repalyTime is expected to be a Number.'))\r\n    }\r\n    this._replayTime = Math.floor(Math.abs(replayTime))\r\n    this._setHistory()\r\n  }\r\n\r\n  _setHistory () {\r\n    const t = this._history.length - this._replayTime\r\n    this._history = this._history.slice(t >= 0 ? t : 0)\r\n  }\r\n\r\n  replayTo (consumer) {\r\n    this._history.forEach(val => {\r\n      consumer(val)\r\n    })\r\n  }\r\n\r\n  replay () {\r\n    this._consumers.forEach((consumer) => {\r\n      this.replayTo(consumer)\r\n    })\r\n  }\r\n\r\n  subscribe (consumer) {\r\n    this._consumers.push(consumer)\r\n    const subscribeController = this._atom.subscribe(consumer)\r\n    this.replayTo(consumer)\r\n    return subscribeController\r\n  }\r\n\r\n  // NOTE: important!!!\r\n  // !!! important\r\n  beObservedBy (...args) {\r\n    return args[0].observe(this)\r\n  }\r\n\r\n  release () {\r\n    this._subscribeController.unsubscribe()\r\n    super.release()\r\n  }\r\n}\r\n\r\nexport const replayWithoutLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: false })\r\n})\r\nexport const replayWithLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: true })\r\n})\r\n","import { pipe, compose } from '../../functional.js'\r\nimport { isObject } from '../../internal.js'\r\n\r\nexport const isAtom = tar => isObject(tar) && tar.isAtom\r\n\r\n/**\r\n * !! please consider BaseMediator when add property or method to BaseAtom\r\n */\r\nexport class BaseAtom {\r\n  get isAtom () {\r\n    return true\r\n  }\r\n\r\n  pipe (...args) {\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    return compose(...args)(this)\r\n  }\r\n}\r\n","import { isUndefined, isObject, isFunction } from '../internal/base.js'\r\nimport { looseCurryN } from '../functional.js'\r\n\r\n// metas\r\n// Terminator\r\n// Vacuo\r\n// Datar\r\n// Mutator\r\n\r\nexport const isDatar = tar => isObject(tar) && tar.isDatar\r\nexport const isMutator = tar => isObject(tar) && tar.isMutator\r\n\r\nexport const isVoid = tar => isObject(tar) && tar.isVoid\r\nexport const isTerminator = tar => isObject(tar) && tar.isTerminator\r\nexport const isVacuo = tar => isFunction(tar) && tar.isVacuo\r\n\r\n/**\r\n *—————————————————————————————————————————————— Nothing Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Void {\r\n  get isVoid () {\r\n    return true\r\n  }\r\n}\r\nexport const VOID = new Void()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Terminator Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Terminator {\r\n  get isTerminator () {\r\n    return true\r\n  }\r\n}\r\nexport const TERMINATOR = new Terminator()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Vacuo Particle ————————————————————————————————————————————————————\r\n */\r\n//  利用 JavaScript Function is also an Object 的特性\r\n//  使 Vacuo 既能够作为 Datar.of() 也能作为 Mutator.of() 的参数\r\n//    从而实现 Empty Datar 和 Empty Mutator\r\n//  https://developer.chrome.com/docs/apps/contentSecurityPolicy/\r\n//  因为要兼容浏览器扩展的执行环境，所以 class Vacuo extends Function 语法无法使用\r\nexport const Vacuo = () => {\r\n  const internalVacuo = function () {}\r\n  Object.defineProperty(internalVacuo, 'isVacuo', {\r\n    get: () => {\r\n      return true\r\n    }\r\n  })\r\n  Object.defineProperty(internalVacuo, 'isEmpty', {\r\n    get: () => {\r\n      return true\r\n    }\r\n  })\r\n  return internalVacuo\r\n}\r\nexport const VACUO = Vacuo()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Datar Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Datar {\r\n  constructor (value, mutator = VACUO) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError('Only the Mutator or Vacuo type of particle is expected to be received as 2nd parameter of Datar particle constructor.'))\r\n    }\r\n    this.value = value\r\n    this.mutator = mutator\r\n  }\r\n\r\n  static of (value) {\r\n    return new Datar(value)\r\n  }\r\n\r\n  static empty () {\r\n    return new Datar(VACUO)\r\n  }\r\n\r\n  get isDatar () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return isVacuo(this.value)\r\n  }\r\n\r\n  fill (mutator) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError('Only the Mutator or Vacuo type of particle is expected to be received by \"fill\" method of Datar particle.'))\r\n    }\r\n    this.mutator = mutator\r\n    return this\r\n  }\r\n\r\n  // 很少用到，之所以存在是为了保证 Datar 和 Mutator 的对称性\r\n  run (mutator = VACUO) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError('Only the Mutator or Vacuo type of particle is expected to be received by \"run\" method of Datar particle.'))\r\n    }\r\n    return isMutator(mutator) ? mutator.operation : mutator\r\n  }\r\n}\r\n\r\nconst checkOperation = operation => {\r\n  if (!isFunction(operation)) {\r\n    throw (new TypeError('operation must be the type of Function.'))\r\n  }\r\n}\r\n// isValidOpTar(isValidOperationTarget) :: any -> Boolean\r\nconst isValidOpTar = tar => {\r\n  return isDatar(tar) || isVacuo(tar)\r\n}\r\n/**\r\n *—————————————————————————————————————————————— Mutator Particle ————————————————————————————————————————————————————\r\n */\r\nexport class Mutator {\r\n  constructor (operation, datar = VACUO) {\r\n    if (!isUndefined(datar) && !isValidOpTar(datar)) {\r\n      throw (new TypeError('Only the Datar or Vacuo type of particle is expected to be received as 2nd parameter of Mutator particle constructor.'))\r\n    }\r\n    checkOperation(operation)\r\n    this.operation = operation\r\n    this.datar = datar\r\n  }\r\n\r\n  static of (operation) {\r\n    return new Mutator(operation)\r\n  }\r\n\r\n  static empty () {\r\n    return new Mutator(VACUO)\r\n  }\r\n\r\n  get isMutator () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return isVacuo(this.operation)\r\n  }\r\n\r\n  static checkOperation (operation) {\r\n    checkOperation(operation)\r\n  }\r\n\r\n  static isValidOpTar (tar) {\r\n    return isValidOpTar(tar)\r\n  }\r\n\r\n  // lift dispatcher\r\n  static lift (operation, options) {\r\n    const { type } = options\r\n\r\n    if (type === 'both') {\r\n      return this.liftBoth(operation)\r\n    } else if (type === 'left') {\r\n      return this.liftLeft(operation)\r\n    } else if (type === 'right') {\r\n      return this.liftRight(operation)\r\n    } else {\r\n      throw (new TypeError(`\"type\" of lift must be one of \"both\" | \"left\" | \"right\", but receives \"${type}\"`))\r\n    }\r\n  }\r\n\r\n  // Automatically unwrap both left & right param to value\r\n  static liftBoth (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOpTar(prevDatar) ? prevDatar.value : prevDatar,\r\n        isValidOpTar(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  // Automatically unwrap left param to value， keep right param Datar\r\n  static liftLeft (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOpTar(prevDatar) ? prevDatar.value : prevDatar,\r\n        datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  // Automatically unwrap right param to value， keep left param Datar\r\n  static liftRight (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        prevDatar,\r\n        isValidOpTar(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  fill (datar) {\r\n    if (!isValidOpTar(datar)) {\r\n      throw (new TypeError('Only the Datar or Vacuo type of particle is expected to be received by \"fill\" method of Mutator particle.'))\r\n    }\r\n    this.datar = datar\r\n    return this\r\n  }\r\n\r\n  run (datar = VACUO, ...args) {\r\n    // 保证 Mutator 的 operation 接收到的两个必要参数都是合法的操作对象\r\n    return this.operation(this.datar, isValidOpTar(datar) ? datar : Datar.of(datar), ...args)\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isData } from './data.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\nexport const isMutation = tar => isObject(tar) && tar.isMutation\r\n\r\nexport class Mutation extends BaseAtom {\r\n  // mutation 其实是一个函数\r\n  // mutation :: a -> a\r\n  constructor (operation, options) {\r\n    super()\r\n    if (isMutator(operation)) {\r\n      this._mutator = operation\r\n    } else if (isFunction(operation)) {\r\n      this._mutator = Mutator.of(operation)\r\n    } else {\r\n      throw new TypeError('Param of Mutation constructor must be a Mutator or a Function.')\r\n    }\r\n    if (options) {\r\n      this._options = options\r\n    }\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  get type () {\r\n    return 'MutationAtom'\r\n  }\r\n\r\n  get isMutation () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._mutator.isEmpty\r\n  }\r\n\r\n  // operation :: (datar, datar) -> any\r\n  // operation :: (value, datar) -> any\r\n  // operation :: (datar, value) -> any\r\n  // operation :: (value, value) -> any\r\n  static of (operation) {\r\n    return new Mutation(operation)\r\n  }\r\n\r\n  static empty () {\r\n    return new Mutation(Mutator.empty())\r\n  }\r\n\r\n  static ofLift (operation, options) {\r\n    return new Mutation(Mutator.lift(operation, options), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftBoth (operation) {\r\n    return new Mutation(Mutator.liftBoth(operation), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftLeft (operation) {\r\n    return new Mutation(Mutator.liftLeft(operation), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftRight (operation) {\r\n    return new Mutation(Mutator.liftRight(operation), { isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  // Mutation 常规值\r\n  get mutator () { return this._mutator }\r\n  get operation () {\r\n    if (this._options && this._options.isLifted) {\r\n      return this._options.origin_operation\r\n    } else {\r\n      return this._mutator.operation\r\n    }\r\n  }\r\n\r\n  // Mutation 流式值\r\n  // consumer :: f -> ()\r\n  // subscribe :: (f -> ()) -> SubscribeController\r\n  subscribe (consumer) {\r\n    // 维护 consumer 列表\r\n    // 保证数据 mutate 之后 notify/trigger consumer\r\n    // unsubscribe 机制\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  trigger (mutator) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator)) {\r\n      throw (new TypeError('Mutation must be triggered with a Mutator.'))\r\n    }\r\n    const _mutator = mutator || this.mutator\r\n    if (!isEmpty(_mutator)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_mutator)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerOperation (operation) {\r\n    return this.trigger(Mutator.of(operation))\r\n  }\r\n\r\n  // Mutation 流式变更 1\r\n  observe (data) {\r\n    if (!isData(data)) {\r\n      throw (new TypeError('Mutation can only observe a Data!'))\r\n    }\r\n    return data.subscribe(datar => {\r\n      this.mutate(datar)\r\n    })\r\n  }\r\n\r\n  // Mutation 流式变更 2\r\n  beObservedBy (data) {\r\n    return data.observe(this)\r\n  }\r\n\r\n  // Mutation 常规变更\r\n  // mutate :: Datar -> Mutation\r\n  // mutate :: Data -> Mutation\r\n  // mutate :: Any -> Mutation\r\n  mutate (data) {\r\n    let _datar = null\r\n    if (isDatar(data)) {\r\n      _datar = data\r\n    } else if (isData(data)) {\r\n      _datar = data.datar\r\n    } else {\r\n      _datar = Datar.of(data)\r\n    }\r\n\r\n    if (isTerminator(_datar.value)) return this\r\n\r\n    // 运行效果相当于：const _tempMutator = this._mutator.fill(_datar)\r\n    // 但实际意义完全不同\r\n    const _tempMutator = Mutator.of(_datar.run(this._mutator)).fill(_datar)\r\n\r\n    this._mutator = _tempMutator\r\n    this.trigger()\r\n\r\n    return this\r\n  }\r\n\r\n  // registerTrigger :: ((mutator -> trigger(mutator)) -> controller, options) -> controller\r\n  // registerTrigger :: ((operation -> trigger(mutator)) -> controller, options) -> controller\r\n  registerTrigger (trigger, { forceWrap = false } = {}) {\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isMutator(args[0]) || forceWrap) {\r\n        args[0] = Mutator.of(args[0])\r\n      }\r\n      this.trigger(...args)\r\n    }\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isMutation } from './mutation.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\nexport const isData = tar => isObject(tar) && tar.isData\r\n\r\nexport class Data extends BaseAtom {\r\n  constructor (value) {\r\n    super()\r\n    if (isDatar(value)) {\r\n      this._datar = value\r\n    } else {\r\n      this._datar = Datar.of(value)\r\n    }\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  get type () {\r\n    return 'DataAtom'\r\n  }\r\n\r\n  get isData () {\r\n    return true\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._datar.isEmpty\r\n  }\r\n\r\n  static of (value) {\r\n    return new Data(value)\r\n  }\r\n\r\n  // Data.empty() <=> Data.of(VACUO)\r\n  static empty () {\r\n    return new Data(Datar.empty())\r\n  }\r\n\r\n  // Data 常规值\r\n  get datar () { return this._datar }\r\n  get value () { return this._datar.value }\r\n\r\n  // Data 流式值\r\n  // consumer:: a -> ()\r\n  // subscribe :: (a -> ()) -> SubscribeController\r\n  subscribe (consumer) {\r\n    // 维护 consumer 列表\r\n    // 保证数据 mutate 之后 notify/trigger consumer\r\n    // unsubscribe 机制\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  trigger (datar) {\r\n    if (!isUndefined(datar) && !isDatar(datar)) {\r\n      throw (new TypeError('Data must be triggered with a Datar.'))\r\n    }\r\n    const _datar = datar || this.datar\r\n    if (!isEmpty(_datar)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_datar)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerValue (value) {\r\n    return this.trigger(Datar.of(value))\r\n  }\r\n\r\n  // Data 流式变更 1\r\n  observe (mutation) {\r\n    if (!isMutation(mutation)) {\r\n      throw (new TypeError('Data can only observe a Mutation!'))\r\n    }\r\n    return mutation.subscribe(mutator => {\r\n      this.mutate(mutator)\r\n    })\r\n  }\r\n\r\n  // Data 流式变更 2\r\n  beObservedBy (mutation) {\r\n    return mutation.observe(this)\r\n  }\r\n\r\n  // Data 常规变更\r\n  // 接收 mutation -> mutation 执行数据变更 -> 保存 mutation 结果 -> 广播 mutation 结果\r\n  // mutate :: Mutation -> Data\r\n  // mutator :: Mutator -> Data\r\n  // mutate :: f -> Data\r\n  mutate (mutation) {\r\n    let _mutator = null\r\n    if (isMutator(mutation)) {\r\n      _mutator = mutation\r\n    } else if (isMutation(mutation)) {\r\n      _mutator = mutation.mutator\r\n    } else if (isFunction(mutation)) {\r\n      _mutator = Mutator.of(mutation)\r\n    } else {\r\n      throw (new TypeError('Param of \"mutate\" must be a Mutation or a Mutator or a normal Function.'))\r\n    }\r\n\r\n    const _tempDatar = Datar.of(_mutator.run(this._datar)).fill(_mutator)\r\n\r\n    // NOTE: If result of operation is TERMINATOR,\r\n    // do not update the datar or trigger the subscribers\r\n    if (!isTerminator(_tempDatar.value)) {\r\n      this._datar = _tempDatar\r\n      this.trigger()\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // registerTrigger :: ((datar -> trigger(datar)) -> controller, options) -> controller\r\n  // registerTrigger :: ((value -> trigger(mutator)) -> controller, options) -> controller\r\n  registerTrigger (trigger, { forceWrap = false } = {}) {\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isDatar(args[0]) || forceWrap) {\r\n        args[0] = Datar.of(args[0])\r\n      }\r\n      return this.trigger(...args)\r\n    }\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","// Mobius flavor Base Library for MINA development\r\nimport { replayWithLatest, Data } from 'MobiusUtils'\r\n\r\nexport const makeThemeService = () => {\r\n  // initial current theme state when first called\r\n  const initialTheme = wx.getSystemInfoSync().theme\r\n\r\n  const themeRD = replayWithLatest(1, Data.of(initialTheme))\r\n\r\n  // update theme state when theme change happen\r\n  wx.onThemeChange(({ theme }) => {\r\n    themeRD.triggerValue(theme)\r\n  })\r\n\r\n  return {\r\n    themeRD\r\n  }\r\n}\r\n\r\nconst themeServices = {}\r\nexport const getThemeService = (scope) => {\r\n  themeServices[scope] = themeServices[scope] || makeThemeService()\r\n  return themeServices[scope]\r\n} ","import { getThemeService } from 'MINA/base/index.js'\r\n\r\nconst { themeRD } = getThemeService('app')\r\n\r\nPage({\r\n  data: {\r\n    message: 'Hello, MINA template! Me page!',\r\n    theme: ''\r\n  },\r\n  onLoad: function (options) {\r\n    console.log('[page launch] me')\r\n    themeRD.subscribe(({ value }) => {\r\n      this.setData({ theme: value })\r\n    })\r\n  }\r\n})\r\n"],"sourceRoot":""}