{"version":3,"sources":["webpack://mina-template/../node_modules/@we-mobius/mobius-mina/src/es/theme.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/base.atom.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/meta.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/mutation.atom.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/atoms/data.atom.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/base.mediators.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/atom/mediators/replay.mediators.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/functional/helpers.js","webpack://mina-template/../node_modules/@we-mobius/mobius-utils/src/es/internal/base.js"],"names":["themeServices","getThemeService","scope","initialTheme","wx","getSystemInfoSync","theme","themeRD","onThemeChange","triggerValue","makeThemeService","isAtom","tar","BaseAtom","args","this","isDatar","isMutator","isVacuo","VACUO","internalVacuo","Object","defineProperty","get","Vacuo","value","mutator","options","TypeError","_options","fill","operation","checkOperation","isValidOperationTarget","datar","type","liftBoth","liftLeft","liftRight","prevDatar","of","isMutation","Data","super","_datar","_consumers","Set","isEmpty","consumer","add","unsubscribe","delete","forEach","trigger","mutation","subscribe","mutate","observe","_mutator","_mutation","_tempDatar","run","isTerminator","forceWrap","BaseMediator","atom","Error","_atom","isData","triggerOperation","beObservedBy","registerTrigger","ReplayMediator","replayTime","_history","setReplayTime","_subscribeController","val","push","_setHistory","isReplayMediator","autoTrigger","_mediator","_replayTime","Math","floor","abs","t","length","slice","replayTo","subscribeController","release","replayWithLatest","_complement","fn","compose","x","isArgPlaceholder","placeholder","prototype","hasOwnProperty","call","internalCurry","filled","innerArgs","map","innerArg","shift","concat","targetNum","validArgs","filter","extraArgs","curry","internalCurryN","n","args2","curryN","internalLooseCurryN","looseCurryN","composeL","fns","reduce","g","f","composeR","reverse","pipe","invokerFactory","curryFn","key","target","isString","str","toString","isNumber","num","isUndefined","isFunction","isObject","obj","isEmptyArr","arr","isArray","isNull","keys","asIs","v"],"mappings":"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","file":"vendors.js","sourcesContent":["// Mobius flavor Base Library for MINA development\r\nimport { replayWithLatest, Data } from '../libs/mobius-utils.js'\r\n\r\nexport const makeThemeService = () => {\r\n  // initial current theme state when first called\r\n  const initialTheme = wx.getSystemInfoSync().theme\r\n\r\n  const themeRD = replayWithLatest(1, Data.of(initialTheme))\r\n\r\n  // update theme state when theme change happen\r\n  wx.onThemeChange(({ theme }) => {\r\n    console.log(theme)\r\n    themeRD.triggerValue(theme)\r\n  })\r\n\r\n  return {\r\n    themeRD\r\n  }\r\n}\r\n\r\nconst themeServices = {}\r\nexport const getThemeService = (scope) => {\r\n  console.log(scope, themeServices)\r\n  themeServices[scope] = themeServices[scope] || makeThemeService()\r\n  console.log(scope, themeServices)\r\n  return themeServices[scope]\r\n}\r\n","import { pipe, compose } from '../../functional.js'\r\nimport { isObject } from '../../internal.js'\r\n\r\nexport const isAtom = tar => isObject(tar) && tar.isAtom\r\n\r\n/**\r\n * !! please consider BaseMediator when add property or method to BaseAtom\r\n */\r\nexport class BaseAtom {\r\n  get isAtom () {\r\n    return true\r\n  }\r\n\r\n  pipe (...args) {\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    return compose(...args)(this)\r\n  }\r\n}\r\n","import { isUndefined, isString, isObject, isFunction } from '../internal/base.js'\r\nimport { looseCurryN } from '../functional.js'\r\n\r\n/**\r\n *    Metas\r\n * Void       -> Void's role in Atom world is same as undefined & null 's role in normal JavaScript world.\r\n *               It is designed to replace values that can be converted to false, such as undefined & null.\r\n *               So falsy values can flowing through the Atoms as normal values flowing.\r\n *               For the typical usages, please check nilToVoidT & defaultT.\r\n * Terminator -> Terminator is designed as a signal for \"interruption\" of Atom Flow.\r\n *               Mutation will not mutate(trigger an operation to update the downstream data's value)\r\n *                 a Data or Datar which value is Terminator.\r\n *               Data will not mutate(update own value to income operation's result) a Mutation or Mutator or Operation\r\n *                 which result is Terminator.\r\n *               For the typical usages, please check filterT or skipT or takeT.\r\n * Vacuo      -> A value that can serve as the value (for Datar, or operation for Mutator)\r\n *                 of Datar and Mutator at the same time.\r\n * Datar      -> Designed to carry the value of Data.\r\n * Mutator    -> Designed to carry the operation of Mutation.\r\n */\r\n\r\nexport const isDatar = tar => isObject(tar) && tar.isDatar\r\nexport const isMutator = tar => isObject(tar) && tar.isMutator\r\n\r\nexport const isVoid = tar => isObject(tar) && tar.isVoid\r\nexport const isTerminator = tar => isObject(tar) && tar.isTerminator\r\nexport const isVacuo = tar => isFunction(tar) && tar.isVacuo\r\n\r\n/**\r\n *—————————————————————————————————————————————— Nothing Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n *\r\n */\r\nexport class Void {\r\n  get isVoid () { return true }\r\n}\r\nexport const VOID = new Void()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Terminator Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n *\r\n */\r\nexport class Terminator {\r\n  get isTerminator () { return true }\r\n}\r\nexport const TERMINATOR = new Terminator()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Vacuo Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n * 利用 JavaScript Function is also an Object 的特性，\r\n * 使 Vacuo 既能够作为 Datar.of() 也能作为 Mutator.of() 的参数，\r\n * 从而实现 Empty Datar 和 Empty Mutator。\r\n *\r\n * 因为要兼容浏览器扩展的执行环境，所以 class Vacuo extends Function 语法无法使用\r\n *   -> Refer: https://developer.chrome.com/docs/apps/contentSecurityPolicy/\r\n */\r\nexport const Vacuo = () => {\r\n  const internalVacuo = function () {}\r\n  Object.defineProperty(internalVacuo, 'isVacuo', {\r\n    get: () => { return true }\r\n  })\r\n  Object.defineProperty(internalVacuo, 'isEmpty', {\r\n    get: () => { return true }\r\n  })\r\n  return internalVacuo\r\n}\r\nexport const VACUO = Vacuo()\r\n\r\n/**\r\n *—————————————————————————————————————————————— Datar Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n *\r\n */\r\nexport class Datar {\r\n  constructor (value, mutator = VACUO, options = {}) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError(\r\n        `The 2nd parameter of Datar's constructor is expected to be type of \"Mutator\" | \"Vacuo\" | \"Undefined\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n\r\n    this._options = options\r\n\r\n    this.value = value\r\n    this.mutator = mutator\r\n  }\r\n\r\n  static of (value, mutator = undefined, options = {}) {\r\n    return new Datar(value, mutator, options)\r\n  }\r\n\r\n  static empty () {\r\n    return new Datar(VACUO)\r\n  }\r\n\r\n  get isDatar () { return true }\r\n\r\n  get isEmpty () { return isVacuo(this.value) }\r\n\r\n  /**\r\n   * @param { Mutator | Vacuo } mutator\r\n   * @return { Datar } this(Datar)\r\n   */\r\n  fill (mutator) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError(\r\n        `The 1st parameter of Datar's fill method is expected to be type of \"Mutator\" | \"Vacuo\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n    this.mutator = mutator\r\n    return this\r\n  }\r\n\r\n  fillEmpty () {\r\n    this.mutator = VACUO\r\n    return this\r\n  }\r\n\r\n  fillAuto (mutator = VACUO) {\r\n    return this.fill(mutator)\r\n  }\r\n\r\n  /**\r\n   * Rarely used, this method exists to ensure the symmetry of Datar and Mutator.\r\n   *\r\n   * @param { Mutator | Vacuo } mutator default to VACUO\r\n   * @return { function | Vacuo } operation function | Vacuo\r\n   */\r\n  run (mutator = VACUO, ...args) {\r\n    if (!isMutator(mutator) && !isVacuo(mutator)) {\r\n      throw (new TypeError(\r\n        `The 1st parameter of Datar's run method is expected to be type of \"Mutator\" | \"Vacuo\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n    // return operation or vacuo\r\n    return isMutator(mutator) ? mutator.operation : mutator\r\n  }\r\n}\r\n\r\n/**\r\n *—————————————————————————————————————————————— Mutator Particle ————————————————————————————————————————————————————\r\n */\r\n/**\r\n * @param { any } operation\r\n */\r\nconst checkOperation = operation => {\r\n  if (!isFunction(operation)) {\r\n    throw (new TypeError(`\"operation\" is expected to be type of \"Function\", but received \"${typeof operation}\".`))\r\n  }\r\n}\r\n/**\r\n * @param { any } tar\r\n * @return { boolean } true | false\r\n */\r\nconst isValidOperationTarget = tar => isDatar(tar) || isVacuo(tar)\r\n/**\r\n *\r\n */\r\nexport class Mutator {\r\n  constructor (operation, datar = VACUO, options = {}) {\r\n    if (!isUndefined(datar) && !isValidOperationTarget(datar)) {\r\n      throw (new TypeError(\r\n        `The 2nd parameter of Mutator's constructor is expected to be type of \"Datar\" | \"Vacuo\" | \"Undefined\", but received \"${typeof datar}\".`\r\n      ))\r\n    }\r\n    checkOperation(operation)\r\n\r\n    this._options = options\r\n\r\n    this.operation = operation\r\n    this.datar = datar\r\n  }\r\n\r\n  static of (operation, datar = undefined, options = {}) {\r\n    return new Mutator(operation, datar, options)\r\n  }\r\n\r\n  static empty () {\r\n    return new Mutator(VACUO)\r\n  }\r\n\r\n  get isMutator () { return true }\r\n\r\n  get isEmpty () { return isVacuo(this.operation) }\r\n\r\n  static checkOperation (operation) {\r\n    checkOperation(operation)\r\n  }\r\n\r\n  static isValidOpTar (tar) {\r\n    return isValidOperationTarget(tar)\r\n  }\r\n\r\n  static isValidOperationTarget (tar) {\r\n    return isValidOperationTarget(tar)\r\n  }\r\n\r\n  /**\r\n   * Dispatch opration to correct lift method according to the given options.\r\n   *\r\n   * @param { function } operation\r\n   * @param { { type: 'both' | 'left' | 'right' } } options\r\n   */\r\n  static lift (operation, options) {\r\n    if (!options) {\r\n      throw (new TypeError(`\"options\" is required for lift method of Mutator, but received \"${options}\".`))\r\n    }\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(`\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`))\r\n    }\r\n    const { type } = options\r\n\r\n    if (!isString(type)) {\r\n      throw (new TypeError(`\"type\" is expected to be type of \"String\", but received \"${typeof type}\".`))\r\n    }\r\n\r\n    if (type === 'both') {\r\n      return this.liftBoth(operation)\r\n    } else if (type === 'left') {\r\n      return this.liftLeft(operation)\r\n    } else if (type === 'right') {\r\n      return this.liftRight(operation)\r\n    } else {\r\n      throw (new TypeError(`\"type\" is expected be one of \"both\" | \"left\" | \"right\", but received \"${type}\".`))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Automatically unwrap both left & right param to value.\r\n   *\r\n   * @param { function } operation\r\n   * @return { function } curried function(2, loose)\r\n   */\r\n  static liftBoth (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOperationTarget(prevDatar) ? prevDatar.value : prevDatar,\r\n        isValidOperationTarget(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Automatically unwrap left param to value， keep right param Datar.\r\n   *\r\n   * @param { function } operation\r\n   * @return { function } curried function(2, loose)\r\n   */\r\n  static liftLeft (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        isValidOperationTarget(prevDatar) ? prevDatar.value : prevDatar,\r\n        datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Automatically unwrap right param to value， keep left param Datar.\r\n   *\r\n   * @param { function } operation\r\n   * @return { function } curried function(2, loose)\r\n   */\r\n  static liftRight (operation) {\r\n    checkOperation(operation)\r\n    return looseCurryN(2, (prevDatar, datar, ...args) => {\r\n      return operation(\r\n        prevDatar,\r\n        isValidOperationTarget(datar) ? datar.value : datar,\r\n        ...args\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @param { Datar | Vacuo } mutator\r\n   * @return { Mutator } this(Mutator)\r\n   */\r\n  fill (datar) {\r\n    if (!isValidOperationTarget(datar)) {\r\n      throw (new TypeError(\r\n        `The 1st parameter of Mutator's fill method is expected to be type of \"Datar\" | \"Vacuo\", but received \"${typeof mutator}\".`\r\n      ))\r\n    }\r\n    this.datar = datar\r\n    return this\r\n  }\r\n\r\n  fillEmpty () {\r\n    this.datar = VACUO\r\n    return this\r\n  }\r\n\r\n  fillAuto (datar = VACUO) {\r\n    return this.fill(datar)\r\n  }\r\n\r\n  /**\r\n   * Atom Flow: Data A -> Mutation -> Data B\r\n   *\r\n   *   -> Data A is observed by Mutation, Mutation is observed by Data B;\r\n   *\r\n   *   -> Data A emits a datar, Mutation takes that datar as the 1st parameter of operation;\r\n   *\r\n   *   -> Mutation takes datar from Data A, then emits a mutator, Data B will take that mutator;\r\n   *\r\n   *   -> Data B takes mutator from Mutation, then pass its own datar to that mutator's operation as the 2nd parameter;\r\n   *\r\n   *   -> The operation evaluates while it has both two parameters, the result will be wrapped in a new datar;\r\n   *\r\n   *   -> The new datar will be the new datar of Data B.\r\n   *\r\n   * @param { Datar | Vacuo } datar default to VACUO\r\n   * @return { any }\r\n   */\r\n  run (datar = VACUO, ...args) {\r\n    // 保证 Mutator 的 operation 接收到的两个必要参数都是合法的操作对象\r\n    return this.operation(this.datar, isValidOperationTarget(datar) ? datar : Datar.of(datar), ...args)\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isData } from './data.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\n/**\r\n * @param { any } tar\r\n * @return { boolean }\r\n */\r\nexport const isMutation = tar => isObject(tar) && tar.isMutation\r\n\r\nexport class Mutation extends BaseAtom {\r\n  constructor (operation, options = {}) {\r\n    super()\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(\r\n        `\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`\r\n      ))\r\n    }\r\n    this._options = options\r\n\r\n    if (isMutator(operation)) {\r\n      this._mutator = operation\r\n    } else if (isFunction(operation)) {\r\n      this._mutator = Mutator.of(operation)\r\n    } else {\r\n      throw new TypeError(\r\n        `\"operation\" is expected to be type of \"Mutator\" | \"Function\", but received \"${typeof operation}\".`\r\n      )\r\n    }\r\n\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  /**\r\n   * @return { 'MutationAtom' } 'MutationAtom'\r\n   */\r\n  get type () { return 'MutationAtom' }\r\n\r\n  /**\r\n   * @return { true } true\r\n   */\r\n  get isMutation () { return true }\r\n\r\n  get isEmpty () { return this._mutator.isEmpty }\r\n\r\n  static of (operation, options = {}) {\r\n    return new Mutation(operation, options)\r\n  }\r\n\r\n  static empty (options = {}) {\r\n    return new Mutation(Mutator.empty(), options)\r\n  }\r\n\r\n  static ofLift (operation, options = {}) {\r\n    const { liftType: type } = options\r\n    return new Mutation(Mutator.lift(operation, { type }), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftBoth (operation, options = {}) {\r\n    return new Mutation(Mutator.liftBoth(operation), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftLeft (operation, options = {}) {\r\n    return new Mutation(Mutator.liftLeft(operation), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  static ofLiftRight (operation, options = {}) {\r\n    return new Mutation(Mutator.liftRight(operation), { ...options, isLifted: true, origin_operation: operation })\r\n  }\r\n\r\n  /**\r\n   * Static value of Mutation.\r\n   *\r\n   * @return { Mutator } mutator\r\n   */\r\n  get mutator () { return this._mutator }\r\n  /**\r\n   * @return { function } operation\r\n   */\r\n  get operation () {\r\n    if (this._options && this._options.isLifted) {\r\n      return this._options.origin_operation\r\n    } else {\r\n      return this._mutator.operation\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Steram value of Mutation.\r\n   *\r\n   * @param { function } consumer The consumer will be invoked by trigger method when there is a adequate value.\r\n   * @return { { unsubscribe: function } } SubscriptionController\r\n   */\r\n  subscribe (consumer) {\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param { Mutator | undefined } mutator\r\n   * @return { void }\r\n   */\r\n  trigger (mutator) {\r\n    if (!isUndefined(mutator) && !isMutator(mutator)) {\r\n      throw (new TypeError('Mutation must be triggered with a Mutator.'))\r\n    }\r\n    const _mutator = mutator || this.mutator\r\n\r\n    if (!isEmpty(_mutator)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_mutator, this)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerOperation (operation) {\r\n    return this.trigger(Mutator.of(operation))\r\n  }\r\n\r\n  /**\r\n   * Change the value of Mutation in a stream manner.\r\n   *\r\n   * Given \"data\" will be **upstream** of current Mutation, which is different from \"beObservedBy\" method.\r\n   *\r\n   * @param { Mutation } mutation data -> current mutation (-> other data)\r\n   */\r\n  observe (data) {\r\n    if (!isData(data)) {\r\n      throw (new TypeError('Mutation can only observe a Data!'))\r\n    }\r\n    return data.subscribe((datar, data) => {\r\n      this.mutate(datar, data)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Change the value of Mutation in a stream manner.\r\n   *\r\n   * Given \"data\" will be **downstream** of current Mutation, which is different from \"observe\" method.\r\n   *\r\n   * @param { Mutation } mutation (other data ->) current mutation -> data\r\n   */\r\n  beObservedBy (data) {\r\n    return data.observe(this)\r\n  }\r\n\r\n  /**\r\n   * Change the value of Mutation in a static manner.\r\n   *\r\n   * take datar-like param(convert to datar)\r\n   *   -> run datar with current mutator & contexts\r\n   *   -> wrap and save result of datar.run as new mutator\r\n   *   -> trigger consumers with new mutator & contexts\r\n   *\r\n   * @param { Datar | Data | any } datar Will be the 2nd param of mutator's operation.\r\n   * @param { Data } data\r\n   * @return { Mutation } Mutation(this)\r\n   */\r\n  mutate (datar, data) {\r\n    let _datar = null\r\n    if (isDatar(datar)) {\r\n      _datar = datar\r\n    } else if (isData(datar)) {\r\n      _datar = datar.datar\r\n    } else {\r\n      _datar = Datar.of(datar)\r\n    }\r\n\r\n    if (isTerminator(_datar.value)) return this\r\n\r\n    let _data\r\n    if (!data) {\r\n      _data = isData(data) ? datar : _data\r\n    } else {\r\n      if (isData(data)) {\r\n        _data = data\r\n      } else {\r\n        throw (new TypeError(`\"data\" is expected to be type of \"Data\", but received \"${typeof data}\".`))\r\n      }\r\n    }\r\n\r\n    // NOTE: 运行效果相当于：const _tempMutator = this._mutator.fill(_datar)\r\n    // 但实际意义完全不同\r\n    const _tempMutator = Mutator.of(_datar.run(this._mutator, _data)).fill(_datar)\r\n\r\n    this._mutator = _tempMutator\r\n    this.trigger()\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * @param { function } trigger Takes an internalTrigger(Function) as first parameter,\r\n   *                             invoke internalTrigger with any value will lead to\r\n   *                             Mutation's trigger method be triggerd with given value.\r\n   * @param { { forceWrap?: boolean } } options\r\n   * @accept ((mutator -> trigger(mutator)) -> controller, options)\r\n   * @accept ((operation -> trigger(mutator)) -> controller, { forceWrap: true })\r\n   * @return { {} } TriggerController\r\n   */\r\n  registerTrigger (trigger, options = {}) {\r\n    if (!trigger) {\r\n      throw (new TypeError(`\"trigger\" is required, but received \"${trigger}\".`))\r\n    }\r\n    if (!isFunction(trigger)) {\r\n      throw (new TypeError(`\"trigger\" is expected to be type of \"Function\", but received \"${typeof trigger}\".`))\r\n    }\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(`\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`))\r\n    }\r\n\r\n    const { forceWrap = false } = options\r\n\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isMutator(args[0]) || forceWrap) {\r\n        args[0] = Mutator.of(args[0])\r\n      }\r\n      this.trigger(...args)\r\n    }\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","import { isUndefined, isFunction, isObject, isEmpty } from '../../internal.js'\r\nimport { Mutator, Datar, isDatar, isMutator, isTerminator } from '../meta.js'\r\nimport { isMutation } from './mutation.atom.js'\r\nimport { BaseAtom } from './base.atom.js'\r\n\r\n/**\r\n * @param { any } tar\r\n * @return { boolean }\r\n */\r\nexport const isData = tar => isObject(tar) && tar.isData\r\n\r\nexport class Data extends BaseAtom {\r\n  constructor (value, options = {}) {\r\n    super()\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(\r\n        `\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`\r\n      ))\r\n    }\r\n    this._options = options\r\n\r\n    if (isDatar(value)) {\r\n      this._datar = value\r\n    } else {\r\n      this._datar = Datar.of(value)\r\n    }\r\n    this._consumers = new Set()\r\n  }\r\n\r\n  /**\r\n   * @return { 'DataAtom' } 'DataAtom'\r\n   */\r\n  get type () { return 'DataAtom' }\r\n\r\n  /**\r\n   * @return { true } true\r\n   */\r\n  get isData () { return true }\r\n\r\n  get isEmpty () { return this._datar.isEmpty }\r\n\r\n  static of (value, options = {}) {\r\n    return new Data(value, options)\r\n  }\r\n\r\n  /**\r\n   * Same as Data.of(VACUO)\r\n   *\r\n   * @return { Data }\r\n   */\r\n  static empty (options = {}) {\r\n    return new Data(Datar.empty(), options)\r\n  }\r\n\r\n  /**\r\n   * Static value of Data.\r\n   *\r\n   * @return { Datar } datar\r\n   */\r\n  get datar () { return this._datar }\r\n  /**\r\n   * Static value of Data, same as Data.datar.value.\r\n   *\r\n   * @return { any } value\r\n   */\r\n  get value () { return this._datar.value }\r\n\r\n  /**\r\n   * Steram value of Data.\r\n   *\r\n   * @param { function } consumer The consumer will be invoked by trigger method when there is a adequate value.\r\n   * @return { { unsubscribe: function } } SubscriptionController\r\n   */\r\n  subscribe (consumer) {\r\n    this._consumers.add(consumer)\r\n    return {\r\n      unsubscribe: () => {\r\n        return this._consumers.delete(consumer)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param { Datar | undefined } datar\r\n   * @return { void }\r\n   */\r\n  trigger (datar) {\r\n    if (!isUndefined(datar) && !isDatar(datar)) {\r\n      throw (new TypeError('Data must be triggered with a Datar.'))\r\n    }\r\n    const _datar = datar || this.datar\r\n\r\n    if (!isEmpty(_datar)) {\r\n      this._consumers.forEach(consumer => {\r\n        consumer(_datar, this)\r\n      })\r\n    }\r\n  }\r\n\r\n  triggerValue (value) {\r\n    return this.trigger(Datar.of(value))\r\n  }\r\n\r\n  /**\r\n   * Change the value of Data in a stream manner.\r\n   *\r\n   * Given \"mutation\" will be **upstream** of current Data, which is different from \"beObservedBy\" method.\r\n   *\r\n   * @param { Mutation } mutation (other data ->) mutation -> current data\r\n   */\r\n  observe (mutation) {\r\n    if (!isMutation(mutation)) {\r\n      throw (new TypeError('Data can only observe a Mutation!'))\r\n    }\r\n    return mutation.subscribe((mutator, mutation) => {\r\n      this.mutate(mutator, mutation)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Change the value of Data in a stream manner.\r\n   *\r\n   * Given \"mutation\" will be **downstream** of current Data, which is different from \"observe\" method.\r\n   *\r\n   * @param { Mutation } mutation current data -> mutation (-> other data)\r\n   */\r\n  beObservedBy (mutation) {\r\n    return mutation.observe(this)\r\n  }\r\n\r\n  /**\r\n   * Change the value of Data in a static manner.\r\n   *\r\n   * take mutator-like param(convert to mutator)\r\n   *   -> run mutator with current datar & contexts\r\n   *   -> wrap and save result of mutator.run as new datar\r\n   *   -> trigger consumers with new datar & contexts\r\n   *\r\n   * @param { Mutator | Mutation | function } mutator Used to produce new value with current datar.\r\n   * @param { Mutation } mutation Provide to mutator's operation (function) as execute contexts.\r\n   * @return { Data } Data(this)\r\n   */\r\n  mutate (mutator, mutation) {\r\n    let _mutator\r\n    if (isMutator(mutator)) {\r\n      _mutator = mutator\r\n    } else if (isMutation(mutator)) {\r\n      _mutator = mutator.mutator\r\n    } else if (isFunction(mutator)) {\r\n      _mutator = Mutator.of(mutator)\r\n    } else {\r\n      throw (new TypeError(`\"mutator\" is expected to be type of \"Mutator\" | \"Mutation\" | \"Function\", but received \"${typeof mutator}\".`))\r\n    }\r\n    let _mutation\r\n    if (!mutation) {\r\n      _mutation = isMutation(mutator) ? mutator : _mutation\r\n    } else {\r\n      if (isMutation(mutation)) {\r\n        _mutation = mutation\r\n      } else {\r\n        throw (new TypeError(`\"mutation\" is expected to be type of \"Mutation\", but received \"${typeof mutation}\".`))\r\n      }\r\n    }\r\n\r\n    const _tempDatar = Datar.of(_mutator.run(this._datar, _mutation)).fill(_mutator)\r\n\r\n    // NOTE: If result of operation is TERMINATOR,\r\n    // do not update the datar or trigger the subscribers\r\n    if (!isTerminator(_tempDatar.value)) {\r\n      this._datar = _tempDatar\r\n      this.trigger()\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * @param { function } trigger Takes an internalTrigger(Function) as first parameter,\r\n   *                             invoke internalTrigger with any value will lead to\r\n   *                             Data's trigger method be triggerd with given value.\r\n   * @param { { forceWrap?: boolean } } options\r\n   * @accept ((datar -> trigger(datar)) -> controller, options)\r\n   * @accept ((value -> trigger(datar)) -> controller, { forceWrap: true })\r\n   * @return { {} } TriggerController\r\n   */\r\n  registerTrigger (trigger, options = {}) {\r\n    if (!trigger) {\r\n      throw (new TypeError(`\"trigger\" is required, but received \"${trigger}\".`))\r\n    }\r\n    if (!isFunction(trigger)) {\r\n      throw (new TypeError(`\"trigger\" is expected to be type of \"Function\", but received \"${typeof trigger}\".`))\r\n    }\r\n    if (!isObject(options)) {\r\n      throw (new TypeError(`\"options\" is expected to be type of \"Object\", but received \"${typeof options}\".`))\r\n    }\r\n\r\n    const { forceWrap = false } = options\r\n\r\n    const _internalTriggerFunction = (...args) => {\r\n      if (!isDatar(args[0]) || forceWrap) {\r\n        args[0] = Datar.of(args[0])\r\n      }\r\n      return this.trigger(...args)\r\n    }\r\n\r\n    const controller = trigger(_internalTriggerFunction)\r\n    return controller\r\n  }\r\n}\r\n","import { isObject } from '../../internal.js'\r\nimport { pipe, compose } from '../../functional.js'\r\n\r\nexport const isMediator = tar => isObject(tar) && tar.isMediator\r\n\r\nexport class BaseMediator {\r\n  constructor (atom) {\r\n    if (new.target === BaseMediator) {\r\n      throw new Error('BaseMediator can not be instantiated!')\r\n    }\r\n    this._atom = atom\r\n  }\r\n\r\n  /***********************************************************\r\n   *             Mediator's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get isMediator () {\r\n    return true\r\n  }\r\n\r\n  /***********************************************************\r\n   *                Atom's propertys and methods\r\n   ***********************************************************/\r\n\r\n  get atom () {\r\n    return this._atom\r\n  }\r\n\r\n  get isAtom () {\r\n    return this._atom.isAtom\r\n  }\r\n\r\n  get isData () {\r\n    return this._atom.isData\r\n  }\r\n\r\n  get isMutation () {\r\n    return this._atom.isMutation\r\n  }\r\n\r\n  get isEmpty () {\r\n    return this._atom.isEmpty\r\n  }\r\n\r\n  get datar () {\r\n    if (this.isData) {\r\n      return this._atom.datar\r\n    } else {\r\n      throw (new TypeError('There is no \"datar\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get value () {\r\n    if (this.isData) {\r\n      return this._atom.value\r\n    } else {\r\n      throw (new TypeError('There is no \"value\" property on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  get mutator () {\r\n    if (this.isMutation) {\r\n      return this._atom.mutator\r\n    } else {\r\n      throw (new TypeError('There is no \"mutator\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  get operation () {\r\n    if (this.isMutation) {\r\n      return this._atom.operation\r\n    } else {\r\n      throw (new TypeError('There is no \"operation\" property on Data instance.'))\r\n    }\r\n  }\r\n\r\n  subscribe (...args) {\r\n    return this._atom.subscribe(...args)\r\n  }\r\n\r\n  trigger (...args) {\r\n    return this._atom.trigger(...args)\r\n  }\r\n\r\n  triggerValue (...args) {\r\n    if (this.isData) {\r\n      return this._atom.triggerValue(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerValue\" method on Mutation instance.'))\r\n    }\r\n  }\r\n\r\n  triggerOperation (...args) {\r\n    if (this.isMutation) {\r\n      return this._atom.triggerOperation(...args)\r\n    } else {\r\n      throw (new TypeError('There is no \"triggerOperation\" method on Data instance.'))\r\n    }\r\n  }\r\n\r\n  observe (...args) {\r\n    return this._atom.observe(...args)\r\n  }\r\n\r\n  beObservedBy (...args) {\r\n    return this._atom.beObservedBy(...args)\r\n  }\r\n\r\n  mutate (...args) {\r\n    return this._atom.mutate(...args)\r\n  }\r\n\r\n  registerTrigger (...args) {\r\n    return this._atom.registerTrigger(...args)\r\n  }\r\n\r\n  pipe (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.pipe(...args)\r\n    return pipe(...args)(this)\r\n  }\r\n\r\n  compose (...args) {\r\n    // ! do not use:\r\n    // ! return this._atom.compose(...args)\r\n    return compose(...args)(this)\r\n  }\r\n\r\n  release () {\r\n    this._atom = null\r\n  }\r\n}\r\n","import { isObject, isNumber } from '../../internal.js'\r\nimport { isAtom } from '../atom.js'\r\nimport { BaseMediator } from './base.mediators.js'\r\nimport { curryN } from '../../functional.js'\r\n\r\nexport const isReplayMediator = tar => isObject(tar) && tar.isReplayMediator\r\n\r\nexport class ReplayMediator extends BaseMediator {\r\n  constructor (atom, replayTime = 1) {\r\n    super(atom)\r\n    this._history = []\r\n    this._consumers = []\r\n    this.setReplayTime(replayTime)\r\n    this._subscribeController = atom.subscribe(val => {\r\n      this._history.push(val)\r\n      this._setHistory()\r\n    })\r\n  }\r\n\r\n  get type () {\r\n    return 'ReplayMediator'\r\n  }\r\n\r\n  get isReplayMediator () {\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * @param options Number | Object\r\n   */\r\n  static of (atom, options) {\r\n    if (!isAtom(atom)) {\r\n      throw (new TypeError('ReplayMediator can apply to an Atom only.'))\r\n    }\r\n    if (isReplayMediator(atom)) {\r\n      return atom\r\n    }\r\n\r\n    let _options = {}\r\n    if (isNumber(options)) {\r\n      _options.replayTime = options\r\n    } else if (isObject(options)) {\r\n      _options = {\r\n        ..._options,\r\n        ...options\r\n      }\r\n    } else {\r\n      throw new TypeError(`\"options\" argument of ReplayMediator is expected to be type of \"Number\" | \"Object\", but received ${typeof options}.`)\r\n    }\r\n\r\n    const { replayTime, autoTrigger = true } = _options\r\n\r\n    const _mediator = new ReplayMediator(atom, replayTime)\r\n\r\n    if (autoTrigger) {\r\n      atom.trigger()\r\n    }\r\n    return _mediator\r\n  }\r\n\r\n  setReplayTime (replayTime) {\r\n    if (!isNumber(replayTime)) {\r\n      throw (new TypeError('repalyTime is expected to be a Number.'))\r\n    }\r\n    this._replayTime = Math.floor(Math.abs(replayTime))\r\n    this._setHistory()\r\n  }\r\n\r\n  _setHistory () {\r\n    const t = this._history.length - this._replayTime\r\n    this._history = this._history.slice(t >= 0 ? t : 0)\r\n  }\r\n\r\n  replayTo (consumer) {\r\n    this._history.forEach(val => {\r\n      consumer(val)\r\n    })\r\n  }\r\n\r\n  replay () {\r\n    this._consumers.forEach((consumer) => {\r\n      this.replayTo(consumer)\r\n    })\r\n  }\r\n\r\n  subscribe (consumer) {\r\n    this._consumers.push(consumer)\r\n    const subscribeController = this._atom.subscribe(consumer)\r\n    this.replayTo(consumer)\r\n    return subscribeController\r\n  }\r\n\r\n  // NOTE: important!!!\r\n  // !!! important\r\n  beObservedBy (...args) {\r\n    return args[0].observe(this)\r\n  }\r\n\r\n  release () {\r\n    this._subscribeController.unsubscribe()\r\n    super.release()\r\n  }\r\n}\r\n\r\nexport const replayWithoutLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: false })\r\n})\r\nexport const replayWithLatest = curryN(2, (replayTime, atom) => {\r\n  return ReplayMediator.of(atom, { replayTime, autoTrigger: true })\r\n})\r\n","// use '../internal/base.js' instead of '../internal.js' to avoid ↓\r\n//   - ReferenceError: Cannot access '***' before initialization\r\n//   - because some of internal modules import the \"../functional.js\"\r\nimport { asIs, isObject, isFunction } from '../internal/base.js'\r\n\r\n// NOTE: 重复实现了 boolean.js 中的 complement 以避免循环引用\r\nconst _complement = fn => compose(x => !x, fn)\r\n\r\nexport const argPlaceholder = {\r\n  // compatible with ramda.js\r\n  '@@functional/placeholder': true,\r\n  isArgPlaceholder: true\r\n}\r\nexport const isArgPlaceholder = placeholder =>\r\n  isObject(placeholder) && Object.prototype.hasOwnProperty.call(placeholder, 'isArgPlaceholder') && placeholder.isArgPlaceholder\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const looseCurryS = (fn, ...args) => {\r\n  if (args.length >= fn.length) {\r\n    return fn(...args)\r\n  } else {\r\n    return (...args2) => looseCurryS(fn, ...args, ...args2)\r\n  }\r\n}\r\nexport const curryS = (fn, ...args) => {\r\n  const targetNum = fn.length\r\n  if (args.length >= targetNum) {\r\n    return fn(...args.slice(0, targetNum))\r\n  } else {\r\n    return (...args2) => curryS(fn, ...args, ...args2)\r\n  }\r\n}\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalLooseCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurry(fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const looseCurry = (fn, ...args) => internalLooseCurry(fn, [], ...args)\r\nexport const internalCurry = (fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const targetNum = fn.length\r\n  const validArgs = innerArgs.slice(0, targetNum)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= targetNum) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...extraArgs) => internalCurry(fn, validArgs, ...extraArgs)\r\n  }\r\n}\r\nexport const curry = (fn, ...args) => internalCurry(fn, [], ...args)\r\n\r\n// loose curry will pass all of the args it received to target function,\r\n// even if the arg's num greater than initial N\r\nexport const internalCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgs = innerArgs.slice(0, n)\r\n  const validLen = validArgs.filter(_complement(isArgPlaceholder)).length\r\n  if (validLen >= n) {\r\n    return fn(...validArgs)\r\n  } else {\r\n    return (...args2) => internalCurryN(n, fn, validArgs, ...args2)\r\n  }\r\n}\r\nexport const curryN = (n, fn, ...args) => internalCurryN(n, fn, [], ...args)\r\n// export const curry1 = (fn, ...args) => internalCurryN(1, fn, [], ...args) // just for consistency\r\n// export const curry2 = (fn, ...args) => internalCurryN(2, fn, [], ...args)\r\n// ...\r\nexport const internalLooseCurryN = (n, fn, filled, ...args) => {\r\n  let innerArgs = filled || []\r\n  innerArgs = innerArgs.map(innerArg => isArgPlaceholder(innerArg) ? (args.length > 0 ? args.shift() : innerArg) : innerArg)\r\n  innerArgs = innerArgs.concat(args)\r\n  const validArgsLen = innerArgs.slice(0, n).filter(_complement(isArgPlaceholder)).length\r\n  if (validArgsLen >= n) {\r\n    return fn(...innerArgs)\r\n  } else {\r\n    return (...extraArgs) => internalLooseCurryN(n, fn, innerArgs, ...extraArgs)\r\n  }\r\n}\r\n/**\r\n * @return { function | any }\r\n */\r\nexport const looseCurryN = (n, fn, ...args) => internalLooseCurryN(n, fn, [], ...args)\r\n\r\n// NOTE: 另外一种 compose 实现\r\n// @see: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\r\n// const compose = (...args) => value => args.reduceRight((acc, fn) => fn(acc), value)\r\n// 本质是一个闭包，直觉上不喜欢（虽然能够带来一些调试上的好处）\r\n//   -> @see: https://www.freecodecamp.org/news/pipe-and-compose-in-javascript-5b04004ac937/\r\n// 下面这种更符合函数式思维，实现上更接近数学定义\r\nexport const composeL = (...fns) => fns.reduce((g, f) => (...args) => f(g(...args)), fns.shift() || asIs)\r\nexport const composeR = (...fns) => composeL(...fns.reverse())\r\nexport const pipeL = composeR\r\nexport const pipeR = composeL\r\nexport const compose = composeR\r\nexport const pipe = composeL\r\n\r\nexport const memorize = (fn, hasher) => {\r\n  const cache = {}\r\n  hasher = hasher || ((...args) => JSON.stringify(args))\r\n  return (...args) => {\r\n    const hash = hasher(args)\r\n    if (!cache[hash]) {\r\n      cache[hash] = fn.apply(this, args)\r\n    }\r\n    return cache[hash]\r\n  }\r\n}\r\n\r\nconst invokerFactory = curryFn => (n, key) => curryFn(n, (...args) => {\r\n  // curry function controlls how many args will be passed in\r\n  const target = args[args.length - 1]\r\n  if (!target[key]) throw Error(`Can not find \"${key}\" method in target.'`)\r\n  if (!isFunction(target[key])) throw Error(`\"${key}\" property in target is not a function.`)\r\n  return target[key](...args.slice(0, args.length - 1))\r\n})\r\nexport const invoker = invokerFactory(curryN)\r\nexport const looseInvoker = invokerFactory(looseCurryN)\r\n\r\nexport const nAry = curry((n, fn) => curryN(n, fn))\r\nexport const looseNAry = curry((n, fn) => looseCurryN(n, fn))\r\nexport const binary = fn => curry((x, y) => fn(x, y)) // nAry(2, fn)\r\nexport const looseBinary = fn => looseCurry((x, y, ...args) => fn(x, y, ...args)) // looseNAry(2, fn)\r\nexport const unary = fn => x => fn(x)\r\nexport const looseUnary = fn => (x, ...args) => fn(x, ...args)\r\n\r\nexport const tap = fn => (...args) => {\r\n  fn(...args)\r\n  return args[0]\r\n}\r\n/*\r\n                  arguments num controller & curry test\r\n*/\r\n// const add = (x, y, z) => { console.log(x, y, z) }\r\n// unary(add)(1, 2, 3) // 1, undefined, undefined\r\n// binary(add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(1, add)(1, 2, 3) // 1, undefined, undefined\r\n// nAry(2, add)(1, 2, 3) // 1, 2, undefined\r\n// nAry(3, add)(1, 2, 3) // 1, 2, 3\r\n// looseUnary(add)(1, 2, 3) // 1, 2, 3\r\n// looseBinary(add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(1, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(2, add)(1, 2, 3) // 1, 2, 3\r\n// looseNAry(3, add)(1, 2, 3) // 1, 2, 3\r\n\r\n// const gg = (a, b) => {\r\n//   console.warn(a, b)\r\n// }\r\n\r\n// const ff = (a, b) => {\r\n//   curry(gg)(a)\r\n// }\r\n\r\n// ff(1)\r\n","export const isDefined = variable => typeof variable !== 'undefined'\r\n\r\nexport const isGeneralObject = tar => typeof tar === 'object'\r\n\r\n// @see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types\r\nexport const isBoolean = boo => Object.prototype.toString.call(boo) === '[object Boolean]'\r\nexport const isString = str => Object.prototype.toString.call(str) === '[object String]'\r\nexport const isNumber = num => Object.prototype.toString.call(num) === '[object Number]'\r\nexport const isSymbol = symbol => Object.prototype.toString.call(symbol) === '[object Symbol]'\r\nexport const isUndefined = val => Object.prototype.toString.call(val) === '[object Undefined]'\r\nexport const isNull = val => Object.prototype.toString.call(val) === '[object Null]'\r\nexport const isFunction = fn => fn && Object.prototype.toString.call(fn) === '[object Function]'\r\nexport const isDate = date =>\r\n  date && Object.prototype.toString.call(new Date(date)) === '[object Date]' && !!new Date(date).getTime()\r\nexport const isObject = obj => Object.prototype.toString.call(obj) === '[object Object]'\r\nexport const isArray = arr => Object.prototype.toString.call(arr) === '[object Array]'\r\nexport const isMap = map => Object.prototype.toString.call(map) === '[object Map]'\r\nexport const isWeakMap = weakMap => Object.prototype.toString.call(weakMap) === '[object WeakMap]'\r\nexport const isSet = set => Object.prototype.toString.call(set) === '[object Set]'\r\nexport const isWeakSet = weakSet => Object.prototype.toString.call(weakSet) === '[object WeakSet]'\r\nexport const isRegExp = regex => Object.prototype.toString.call(regex) === '[object RegExp]'\r\nexport const isPromise = obj => Object.prototype.toString.call(obj) === '[object Promise]'\r\nexport const isAsyncFn = fn => Object.prototype.toString.call(fn) === '[object AsyncFunction]'\r\nexport const isGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object GeneratorFunction]'\r\nexport const isAsyncGeneratorFunction = fn =>\r\n  Object.prototype.toString.call(fn) === '[object AsyncGeneratorFunction]'\r\nexport const isError = err => Object.prototype.toString.call(err) === '[object Error]'\r\nexport const isEmptyStr = str => isString(str) && str.length === 0\r\nexport const isEmptyArr = arr => isArray(arr) && arr.length === 0\r\nexport const isEmptyObj = obj => isObject(obj) && Object.keys(obj).length === 0\r\nexport const isOutDated = date => isDate(date) && new Date(date).getTime() < new Date().getTime()\r\n\r\nexport const isWindow = obj => Object.prototype.toString.call(obj) === '[object Window]'\r\nexport const isDocument = obj => Object.prototype.toString.call(document) === '[object HTMLDocument]'\r\n// refer: https://developer.mozilla.org/zh-CN/docs/Web/API/Event\r\nexport const isEventTarget = obj => obj instanceof EventTarget\r\nexport const isIterable = tar => Object.prototype.toString.call(tar[Symbol.iterator]) === 'object Function'\r\n\r\nexport const isObservable = obj => isObject(obj) && (obj.isObservable || isFunction(obj.subscribe))\r\n\r\n// - `null` and `undefined` are considered empty values\r\n// - `''` is the empty value for String\r\n// - `[]` is the empty value for Array\r\n// - `{}` is the empty value for Object\r\nexport const isEmpty = val =>\r\n  isNull(val) || isUndefined(val) || isEmptyStr(val) || isEmptyArr(val) || isEmptyObj(val) || (isObject(val) && val.isEmpty)\r\n\r\nexport const asIs = v => v\r\nexport const asUndefined = v => undefined\r\nexport const asNull = v => null\r\nexport const noop = v => {}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n"],"sourceRoot":""}